
/Users/nrobinson/sparkbot-default/firmware//target/.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001b98  080a0018  080a0018  00008018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000000  40024000  40024000  00011c48  2**0
                  CONTENTS
  3 .data         0000006c  20000300  080a1bb0  00010300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000001bc  2000036c  2000036c  0001836c  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a1c1c  080a1c1c  00011c1c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a1c44  080a1c44  00011c44  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   00050a9b  00000000  00000000  00011c48  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000a008  00000000  00000000  000626e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000a861  00000000  00000000  0006c6eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001360  00000000  00000000  00076f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00001928  00000000  00000000  000782ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001b835  00000000  00000000  00079bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00015426  00000000  00000000  00095409  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0006af9c  00000000  00000000  000aa82f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00006ed8  00000000  00000000  001157cc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	ac 18 0a 08                                         ....

080a001c <module_user_init>:

void module_user_init()
{
    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a001c:	4b07      	ldr	r3, [pc, #28]	; (80a003c <module_user_init+0x20>)
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a001e:	b570      	push	{r4, r5, r6, lr}
 80a0020:	461e      	mov	r6, r3
    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0022:	4c07      	ldr	r4, [pc, #28]	; (80a0040 <module_user_init+0x24>)
 80a0024:	2500      	movs	r5, #0
 80a0026:	1ae4      	subs	r4, r4, r3
 80a0028:	08a4      	lsrs	r4, r4, #2
 80a002a:	42a5      	cmp	r5, r4
 80a002c:	d004      	beq.n	80a0038 <module_user_init+0x1c>
    {
        link_constructors_location[ctor_num]();
 80a002e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0032:	4798      	blx	r3

void module_user_init()
{
    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0034:	3501      	adds	r5, #1
 80a0036:	e7f8      	b.n	80a002a <module_user_init+0xe>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a0038:	bd70      	pop	{r4, r5, r6, pc}
 80a003a:	bf00      	nop
 80a003c:	080a1b7c 	.word	0x080a1b7c
 80a0040:	080a1bb0 	.word	0x080a1bb0

080a0044 <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0044:	4809      	ldr	r0, [pc, #36]	; (80a006c <module_user_pre_init+0x28>)
 80a0046:	490a      	ldr	r1, [pc, #40]	; (80a0070 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0048:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a004a:	4288      	cmp	r0, r1
 80a004c:	d005      	beq.n	80a005a <module_user_pre_init+0x16>
 80a004e:	4a09      	ldr	r2, [pc, #36]	; (80a0074 <module_user_pre_init+0x30>)
 80a0050:	4282      	cmp	r2, r0
 80a0052:	d002      	beq.n	80a005a <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a0054:	1a12      	subs	r2, r2, r0
 80a0056:	f001 fb67 	bl	80a1728 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a005a:	4807      	ldr	r0, [pc, #28]	; (80a0078 <module_user_pre_init+0x34>)
 80a005c:	4a07      	ldr	r2, [pc, #28]	; (80a007c <module_user_pre_init+0x38>)
 80a005e:	2100      	movs	r1, #0
 80a0060:	1a12      	subs	r2, r2, r0
 80a0062:	f001 fb6c 	bl	80a173e <memset>
    return &link_heap_start;
}
 80a0066:	4806      	ldr	r0, [pc, #24]	; (80a0080 <module_user_pre_init+0x3c>)
 80a0068:	bd08      	pop	{r3, pc}
 80a006a:	bf00      	nop
 80a006c:	20000300 	.word	0x20000300
 80a0070:	080a1bb0 	.word	0x080a1bb0
 80a0074:	2000036c 	.word	0x2000036c
 80a0078:	2000036c 	.word	0x2000036c
 80a007c:	20000528 	.word	0x20000528
 80a0080:	20000528 	.word	0x20000528

080a0084 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0084:	f000 b824 	b.w	80a00d0 <setup>

080a0088 <module_user_loop>:
}

void module_user_loop() {
    loop();
 80a0088:	f000 b85c 	b.w	80a0144 <loop>

080a008c <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
 80a008c:	f000 bdbc 	b.w	80a0c08 <malloc>

080a0090 <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a0090:	f000 bdc2 	b.w	80a0c18 <free>

080a0094 <_Z17syncServosHandlerPKcS0_>:
SYSTEM_THREAD(ENABLED);

sparkbot sb; // Create sb, an object of the sparkbot class.

void syncServosHandler(const char *event, const char *data)
{
 80a0094:	4603      	mov	r3, r0
 80a0096:	460a      	mov	r2, r1
  sb.syncServosSlave(event, data);
 80a0098:	4801      	ldr	r0, [pc, #4]	; (80a00a0 <_Z17syncServosHandlerPKcS0_+0xc>)
 80a009a:	4619      	mov	r1, r3
 80a009c:	f000 bad2 	b.w	80a0644 <_ZN8sparkbot15syncServosSlaveEPKcS1_>
 80a00a0:	20000370 	.word	0x20000370

080a00a4 <_Z15RGBSlaveHandlerPKcS0_>:
}

void RGBSlaveHandler(const char *event, const char *data)
{
 80a00a4:	4603      	mov	r3, r0
 80a00a6:	460a      	mov	r2, r1
sb.RGBSlave(event, data);
 80a00a8:	4801      	ldr	r0, [pc, #4]	; (80a00b0 <_Z15RGBSlaveHandlerPKcS0_+0xc>)
 80a00aa:	4619      	mov	r1, r3
 80a00ac:	f000 bb36 	b.w	80a071c <_ZN8sparkbot8RGBSlaveEPKcS1_>
 80a00b0:	20000370 	.word	0x20000370

080a00b4 <_Z14webhookHandlerv>:
}

void webhookHandler()
{
 80a00b4:	b507      	push	{r0, r1, r2, lr}
      function(funcKey, std::bind(func, instance, _1));
    }

    bool publish(const char *eventName, Spark_Event_TypeDef eventType=PUBLIC)
    {
        return CLOUD_FN(spark_send_event(eventName, NULL, 60, eventType, NULL), false);
 80a00b6:	2100      	movs	r1, #0
 80a00b8:	9100      	str	r1, [sp, #0]
 80a00ba:	223c      	movs	r2, #60	; 0x3c
 80a00bc:	460b      	mov	r3, r1
 80a00be:	4803      	ldr	r0, [pc, #12]	; (80a00cc <_Z14webhookHandlerv+0x18>)
 80a00c0:	f000 fd8a 	bl	80a0bd8 <spark_send_event>
  // Particle.publish("ATC-Bot", "Hello", PRIVATE);
  Particle.publish("toggleWemo");
}
 80a00c4:	b003      	add	sp, #12
 80a00c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80a00ca:	bf00      	nop
 80a00cc:	080a18c0 	.word	0x080a18c0

080a00d0 <setup>:

void setup() // Mandatory setup function.
{
 80a00d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
sb.begin();
 80a00d2:	4d17      	ldr	r5, [pc, #92]	; (80a0130 <setup+0x60>)
        return CLOUD_FN(spark_send_event(eventName, eventData, ttl, eventType, NULL), false);
    }

    bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope=ALL_DEVICES)
    {
        return CLOUD_FN(spark_subscribe(eventName, handler, NULL, scope, NULL, NULL), false);
 80a00d4:	2400      	movs	r4, #0
 80a00d6:	4628      	mov	r0, r5
 80a00d8:	f000 fb78 	bl	80a07cc <_ZN8sparkbot5beginEv>
interrupts();
 80a00dc:	f000 fe42 	bl	80a0d64 <_Z10interruptsv>
 80a00e0:	4622      	mov	r2, r4
 80a00e2:	4623      	mov	r3, r4
 80a00e4:	9400      	str	r4, [sp, #0]
 80a00e6:	9401      	str	r4, [sp, #4]
 80a00e8:	4912      	ldr	r1, [pc, #72]	; (80a0134 <setup+0x64>)
 80a00ea:	4813      	ldr	r0, [pc, #76]	; (80a0138 <setup+0x68>)
 80a00ec:	f000 fd7c 	bl	80a0be8 <spark_subscribe>
 80a00f0:	4622      	mov	r2, r4
 80a00f2:	4623      	mov	r3, r4
 80a00f4:	9400      	str	r4, [sp, #0]
 80a00f6:	9401      	str	r4, [sp, #4]
 80a00f8:	4910      	ldr	r1, [pc, #64]	; (80a013c <setup+0x6c>)
 80a00fa:	4811      	ldr	r0, [pc, #68]	; (80a0140 <setup+0x70>)
 80a00fc:	f000 fd74 	bl	80a0be8 <spark_subscribe>
"moodlights", Calls moodlightsCloud(red, green, blue), 3 RGB values from 0-255

"checkOnline", Calls the checkOnline function, which updates "onlineBots".

*/
sb.moveNeck(90);
 80a0100:	4628      	mov	r0, r5
 80a0102:	215a      	movs	r1, #90	; 0x5a
 80a0104:	f000 f9ca 	bl	80a049c <_ZN8sparkbot8moveNeckEi>
sb.moveLeft(90);
 80a0108:	4628      	mov	r0, r5
 80a010a:	215a      	movs	r1, #90	; 0x5a
 80a010c:	f000 f9de 	bl	80a04cc <_ZN8sparkbot8moveLeftEi>
sb.moveRight(90);
 80a0110:	4628      	mov	r0, r5
 80a0112:	215a      	movs	r1, #90	; 0x5a
 80a0114:	f000 f9ce 	bl	80a04b4 <_ZN8sparkbot9moveRightEi>
pinMode(I0, OUTPUT);
 80a0118:	200f      	movs	r0, #15
 80a011a:	2101      	movs	r1, #1
 80a011c:	f001 f942 	bl	80a13a4 <pinMode>
pinMode(I4, INPUT);
 80a0120:	4621      	mov	r1, r4
 80a0122:	200c      	movs	r0, #12
}
 80a0124:	b003      	add	sp, #12
 80a0126:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
*/
sb.moveNeck(90);
sb.moveLeft(90);
sb.moveRight(90);
pinMode(I0, OUTPUT);
pinMode(I4, INPUT);
 80a012a:	f001 b93b 	b.w	80a13a4 <pinMode>
 80a012e:	bf00      	nop
 80a0130:	20000370 	.word	0x20000370
 80a0134:	080a0095 	.word	0x080a0095
 80a0138:	080a18cb 	.word	0x080a18cb
 80a013c:	080a00a5 	.word	0x080a00a5
 80a0140:	080a18d6 	.word	0x080a18d6

080a0144 <loop>:
}


void loop() // Mandatory loop function.
{
 80a0144:	b508      	push	{r3, lr}

  sb.refresh();
 80a0146:	4814      	ldr	r0, [pc, #80]	; (80a0198 <loop+0x54>)
 80a0148:	f000 fb18 	bl	80a077c <_ZN8sparkbot7refreshEv>
  if (digitalRead(I4) == HIGH)
 80a014c:	200c      	movs	r0, #12
 80a014e:	f001 f953 	bl	80a13f8 <digitalRead>
 80a0152:	2801      	cmp	r0, #1
 80a0154:	d108      	bne.n	80a0168 <loop+0x24>
  {
      Serial.println("Button pressed!");
 80a0156:	4911      	ldr	r1, [pc, #68]	; (80a019c <loop+0x58>)
 80a0158:	4811      	ldr	r0, [pc, #68]	; (80a01a0 <loop+0x5c>)
 80a015a:	f000 fe76 	bl	80a0e4a <_ZN5Print7printlnEPKc>
      webhookHandler();
 80a015e:	f7ff ffa9 	bl	80a00b4 <_Z14webhookHandlerv>
      delay(250);
 80a0162:	20fa      	movs	r0, #250	; 0xfa
 80a0164:	f000 fd7a 	bl	80a0c5c <delay>
  }

  if (sb.noiseLevel > 700)
 80a0168:	4b0b      	ldr	r3, [pc, #44]	; (80a0198 <loop+0x54>)
 80a016a:	6a1b      	ldr	r3, [r3, #32]
 80a016c:	f5b3 7f2f 	cmp.w	r3, #700	; 0x2bc
 80a0170:	dd10      	ble.n	80a0194 <loop+0x50>
  {
    Serial.println("NOISE!");
 80a0172:	490c      	ldr	r1, [pc, #48]	; (80a01a4 <loop+0x60>)
 80a0174:	480a      	ldr	r0, [pc, #40]	; (80a01a0 <loop+0x5c>)
 80a0176:	f000 fe68 	bl	80a0e4a <_ZN5Print7printlnEPKc>
    digitalWrite(I0, HIGH);
 80a017a:	2101      	movs	r1, #1
 80a017c:	200f      	movs	r0, #15
 80a017e:	f001 f922 	bl	80a13c6 <digitalWrite>
    delay(100);
 80a0182:	2064      	movs	r0, #100	; 0x64
 80a0184:	f000 fd6a 	bl	80a0c5c <delay>
  if (sb.moveRight(180));
  delay(1500);
  if (sb.moveLeft(180));
*/

}
 80a0188:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (sb.noiseLevel > 700)
  {
    Serial.println("NOISE!");
    digitalWrite(I0, HIGH);
    delay(100);
    digitalWrite(I0, LOW);;
 80a018c:	200f      	movs	r0, #15
 80a018e:	2100      	movs	r1, #0
 80a0190:	f001 b919 	b.w	80a13c6 <digitalWrite>
 80a0194:	bd08      	pop	{r3, pc}
 80a0196:	bf00      	nop
 80a0198:	20000370 	.word	0x20000370
 80a019c:	080a18da 	.word	0x080a18da
 80a01a0:	2000046c 	.word	0x2000046c
 80a01a4:	080a18ea 	.word	0x080a18ea

080a01a8 <_GLOBAL__sub_I_sb>:
  if (sb.moveRight(180));
  delay(1500);
  if (sb.moveLeft(180));
*/

}
 80a01a8:	b508      	push	{r3, lr}
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a01aa:	f000 fbe3 	bl	80a0974 <HAL_Pin_Map>
 80a01ae:	4b05      	ldr	r3, [pc, #20]	; (80a01c4 <_GLOBAL__sub_I_sb+0x1c>)
// This is a reference document, as it is heavily commented.  Obviously anything commented
// here is not essential for a barebones sketch.
// Written by Nathan Robinson under GPL 3.0
#include "application.h"
#include "sparkbot-default.h" // Import the sparkbot-default library.
SYSTEM_THREAD(ENABLED);
 80a01b0:	2100      	movs	r1, #0
 80a01b2:	6018      	str	r0, [r3, #0]
 80a01b4:	2001      	movs	r0, #1
 80a01b6:	f000 fcf7 	bl	80a0ba8 <system_thread_set_state>
  if (sb.moveRight(180));
  delay(1500);
  if (sb.moveLeft(180));
*/

}
 80a01ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
// Written by Nathan Robinson under GPL 3.0
#include "application.h"
#include "sparkbot-default.h" // Import the sparkbot-default library.
SYSTEM_THREAD(ENABLED);

sparkbot sb; // Create sb, an object of the sparkbot class.
 80a01be:	4802      	ldr	r0, [pc, #8]	; (80a01c8 <_GLOBAL__sub_I_sb+0x20>)
 80a01c0:	f000 b925 	b.w	80a040e <_ZN8sparkbotC1Ev>
 80a01c4:	20000398 	.word	0x20000398
 80a01c8:	20000370 	.word	0x20000370

080a01cc <_ZN8sparkbot11slaveToggleE6String>:
}


int sparkbot::slaveToggle(String data)
{
  if (slaveMode == true)
 80a01cc:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 80a01d0:	2301      	movs	r3, #1
 80a01d2:	b122      	cbz	r2, 80a01de <_ZN8sparkbot11slaveToggleE6String+0x12>
  {
    slaveMode = false;
 80a01d4:	2200      	movs	r2, #0
 80a01d6:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    return 1;
 80a01da:	4618      	mov	r0, r3
 80a01dc:	4770      	bx	lr
  }

  if (slaveMode == false)
  {
    slaveMode = true;
 80a01de:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return 2;
 80a01e2:	2002      	movs	r0, #2
  }
  return -1;

}
 80a01e4:	4770      	bx	lr
	...

080a01e8 <_ZN8sparkbot15moodlightsCloudE6String>:
  analogWrite(GREENLED, 255);
  greenValue = 255;
}

int sparkbot::moodlightsCloud(String data)
{
 80a01e8:	b530      	push	{r4, r5, lr}
 80a01ea:	460c      	mov	r4, r1
 80a01ec:	b095      	sub	sp, #84	; 0x54
 80a01ee:	4605      	mov	r5, r0
  String red = data.substring(0, 3);
 80a01f0:	2200      	movs	r2, #0
 80a01f2:	4668      	mov	r0, sp
 80a01f4:	2303      	movs	r3, #3
 80a01f6:	f000 ffa1 	bl	80a113c <_ZNK6String9substringEjj>
  String green = data.substring(4, 7);
 80a01fa:	a804      	add	r0, sp, #16
 80a01fc:	4621      	mov	r1, r4
 80a01fe:	2204      	movs	r2, #4
 80a0200:	2307      	movs	r3, #7
 80a0202:	f000 ff9b 	bl	80a113c <_ZNK6String9substringEjj>
  String blue = data.substring(8,11);
 80a0206:	2208      	movs	r2, #8
 80a0208:	230b      	movs	r3, #11
 80a020a:	4621      	mov	r1, r4
 80a020c:	a808      	add	r0, sp, #32
 80a020e:	f000 ff95 	bl	80a113c <_ZNK6String9substringEjj>

  analogWrite(REDLED, red.toInt());
 80a0212:	4668      	mov	r0, sp
 80a0214:	f000 ffba 	bl	80a118c <_ZNK6String5toIntEv>
 80a0218:	b281      	uxth	r1, r0
 80a021a:	2003      	movs	r0, #3
 80a021c:	f001 f916 	bl	80a144c <analogWrite>
  redValue = red.toInt();
 80a0220:	4668      	mov	r0, sp
 80a0222:	f000 ffb3 	bl	80a118c <_ZNK6String5toIntEv>
 80a0226:	6128      	str	r0, [r5, #16]
  analogWrite(GREENLED, green.toInt());
 80a0228:	a804      	add	r0, sp, #16
 80a022a:	f000 ffaf 	bl	80a118c <_ZNK6String5toIntEv>
 80a022e:	b281      	uxth	r1, r0
 80a0230:	2013      	movs	r0, #19
 80a0232:	f001 f90b 	bl	80a144c <analogWrite>
  greenValue = green.toInt();
 80a0236:	a804      	add	r0, sp, #16
 80a0238:	f000 ffa8 	bl	80a118c <_ZNK6String5toIntEv>
 80a023c:	6168      	str	r0, [r5, #20]
  analogWrite(BLUELED, blue.toInt());
 80a023e:	a808      	add	r0, sp, #32
 80a0240:	f000 ffa4 	bl	80a118c <_ZNK6String5toIntEv>
 80a0244:	b281      	uxth	r1, r0
 80a0246:	2011      	movs	r0, #17
 80a0248:	f001 f900 	bl	80a144c <analogWrite>
  blueValue = blue.toInt();
 80a024c:	a808      	add	r0, sp, #32
 80a024e:	f000 ff9d 	bl	80a118c <_ZNK6String5toIntEv>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0252:	4937      	ldr	r1, [pc, #220]	; (80a0330 <_ZN8sparkbot15moodlightsCloudE6String+0x148>)
 80a0254:	61a8      	str	r0, [r5, #24]
 80a0256:	a810      	add	r0, sp, #64	; 0x40
 80a0258:	f000 ff15 	bl	80a1086 <_ZN6StringC1EPKc>

  Serial.println("Original String:" + data);
 80a025c:	4621      	mov	r1, r4
 80a025e:	a810      	add	r0, sp, #64	; 0x40
 80a0260:	f000 ff5f 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a0264:	4603      	mov	r3, r0
 80a0266:	4c33      	ldr	r4, [pc, #204]	; (80a0334 <_ZN8sparkbot15moodlightsCloudE6String+0x14c>)
 80a0268:	6819      	ldr	r1, [r3, #0]
 80a026a:	4620      	mov	r0, r4
 80a026c:	f000 fded 	bl	80a0e4a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0270:	a810      	add	r0, sp, #64	; 0x40
 80a0272:	f000 fec6 	bl	80a1002 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0276:	4930      	ldr	r1, [pc, #192]	; (80a0338 <_ZN8sparkbot15moodlightsCloudE6String+0x150>)
 80a0278:	a810      	add	r0, sp, #64	; 0x40
 80a027a:	f000 ff04 	bl	80a1086 <_ZN6StringC1EPKc>
  Serial.println("RED:" + String(red.toInt()));
 80a027e:	4668      	mov	r0, sp
 80a0280:	f000 ff84 	bl	80a118c <_ZNK6String5toIntEv>
 80a0284:	220a      	movs	r2, #10
 80a0286:	4601      	mov	r1, r0
 80a0288:	a80c      	add	r0, sp, #48	; 0x30
 80a028a:	f000 ff20 	bl	80a10ce <_ZN6StringC1Elh>
 80a028e:	a90c      	add	r1, sp, #48	; 0x30
 80a0290:	a810      	add	r0, sp, #64	; 0x40
 80a0292:	f000 ff46 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a0296:	4603      	mov	r3, r0
 80a0298:	4620      	mov	r0, r4
 80a029a:	6819      	ldr	r1, [r3, #0]
 80a029c:	f000 fdd5 	bl	80a0e4a <_ZN5Print7printlnEPKc>
 80a02a0:	a80c      	add	r0, sp, #48	; 0x30
 80a02a2:	f000 feae 	bl	80a1002 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a02a6:	a810      	add	r0, sp, #64	; 0x40
 80a02a8:	f000 feab 	bl	80a1002 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a02ac:	4923      	ldr	r1, [pc, #140]	; (80a033c <_ZN8sparkbot15moodlightsCloudE6String+0x154>)
 80a02ae:	a810      	add	r0, sp, #64	; 0x40
 80a02b0:	f000 fee9 	bl	80a1086 <_ZN6StringC1EPKc>
  Serial.println("GREEN:" + String(green.toInt()));
 80a02b4:	a804      	add	r0, sp, #16
 80a02b6:	f000 ff69 	bl	80a118c <_ZNK6String5toIntEv>
 80a02ba:	220a      	movs	r2, #10
 80a02bc:	4601      	mov	r1, r0
 80a02be:	a80c      	add	r0, sp, #48	; 0x30
 80a02c0:	f000 ff05 	bl	80a10ce <_ZN6StringC1Elh>
 80a02c4:	a90c      	add	r1, sp, #48	; 0x30
 80a02c6:	a810      	add	r0, sp, #64	; 0x40
 80a02c8:	f000 ff2b 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a02cc:	4603      	mov	r3, r0
 80a02ce:	4620      	mov	r0, r4
 80a02d0:	6819      	ldr	r1, [r3, #0]
 80a02d2:	f000 fdba 	bl	80a0e4a <_ZN5Print7printlnEPKc>
 80a02d6:	a80c      	add	r0, sp, #48	; 0x30
 80a02d8:	f000 fe93 	bl	80a1002 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a02dc:	a810      	add	r0, sp, #64	; 0x40
 80a02de:	f000 fe90 	bl	80a1002 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a02e2:	4917      	ldr	r1, [pc, #92]	; (80a0340 <_ZN8sparkbot15moodlightsCloudE6String+0x158>)
 80a02e4:	a810      	add	r0, sp, #64	; 0x40
 80a02e6:	f000 fece 	bl	80a1086 <_ZN6StringC1EPKc>
  Serial.println("BLUE:" + String(blue.toInt()));
 80a02ea:	a808      	add	r0, sp, #32
 80a02ec:	f000 ff4e 	bl	80a118c <_ZNK6String5toIntEv>
 80a02f0:	220a      	movs	r2, #10
 80a02f2:	4601      	mov	r1, r0
 80a02f4:	a80c      	add	r0, sp, #48	; 0x30
 80a02f6:	f000 feea 	bl	80a10ce <_ZN6StringC1Elh>
 80a02fa:	a90c      	add	r1, sp, #48	; 0x30
 80a02fc:	a810      	add	r0, sp, #64	; 0x40
 80a02fe:	f000 ff10 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a0302:	4603      	mov	r3, r0
 80a0304:	4620      	mov	r0, r4
 80a0306:	6819      	ldr	r1, [r3, #0]
 80a0308:	f000 fd9f 	bl	80a0e4a <_ZN5Print7printlnEPKc>
 80a030c:	a80c      	add	r0, sp, #48	; 0x30
 80a030e:	f000 fe78 	bl	80a1002 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0312:	a810      	add	r0, sp, #64	; 0x40
 80a0314:	f000 fe75 	bl	80a1002 <_ZN6StringD1Ev>

int sparkbot::moodlightsCloud(String data)
{
  String red = data.substring(0, 3);
  String green = data.substring(4, 7);
  String blue = data.substring(8,11);
 80a0318:	a808      	add	r0, sp, #32
 80a031a:	f000 fe72 	bl	80a1002 <_ZN6StringD1Ev>
}

int sparkbot::moodlightsCloud(String data)
{
  String red = data.substring(0, 3);
  String green = data.substring(4, 7);
 80a031e:	a804      	add	r0, sp, #16
 80a0320:	f000 fe6f 	bl	80a1002 <_ZN6StringD1Ev>

  Serial.println("Original String:" + data);
  Serial.println("RED:" + String(red.toInt()));
  Serial.println("GREEN:" + String(green.toInt()));
  Serial.println("BLUE:" + String(blue.toInt()));
  return 1;
 80a0324:	4668      	mov	r0, sp
 80a0326:	f000 fe6c 	bl	80a1002 <_ZN6StringD1Ev>
}
 80a032a:	2001      	movs	r0, #1
 80a032c:	b015      	add	sp, #84	; 0x54
 80a032e:	bd30      	pop	{r4, r5, pc}
 80a0330:	080a18f1 	.word	0x080a18f1
 80a0334:	2000046c 	.word	0x2000046c
 80a0338:	080a1902 	.word	0x080a1902
 80a033c:	080a1907 	.word	0x080a1907
 80a0340:	080a190e 	.word	0x080a190e

080a0344 <_ZN10CloudClass8variableI20CloudVariableTypeIntEEbPKcNT_6varrefERKS4_.isra.4>:
        return variable(varKey, (const char*)userVar, userVarType);
    }

    template<typename T> static inline bool variable(const char *varKey, const typename T::varref userVar, const T& userVarType)
    {
        return CLOUD_FN(spark_variable(varKey, (const void*)userVar, T::value(), NULL), false);
 80a0344:	2202      	movs	r2, #2
 80a0346:	2300      	movs	r3, #0
 80a0348:	f000 bc36 	b.w	80a0bb8 <spark_variable>

080a034c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a034c:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a034e:	b538      	push	{r3, r4, r5, lr}
 80a0350:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a0352:	d005      	beq.n	80a0360 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation+0x14>
 80a0354:	2a03      	cmp	r2, #3
 80a0356:	d00f      	beq.n	80a0378 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation+0x2c>
 80a0358:	2a01      	cmp	r2, #1
 80a035a:	d110      	bne.n	80a037e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation+0x32>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a035c:	680b      	ldr	r3, [r1, #0]
 80a035e:	e009      	b.n	80a0374 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation+0x28>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a0360:	200c      	movs	r0, #12
 80a0362:	680d      	ldr	r5, [r1, #0]
 80a0364:	f7ff fe92 	bl	80a008c <_Znwj>
 80a0368:	4603      	mov	r3, r0
 80a036a:	b118      	cbz	r0, 80a0374 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation+0x28>
 80a036c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80a0370:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 80a0374:	6023      	str	r3, [r4, #0]
 80a0376:	e002      	b.n	80a037e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt7_Mem_fnIM8sparkbotFi6StringEEPS3_St12_PlaceholderILi1EEEEE10_M_managerERSt9_Any_dataRKSE_St18_Manager_operation+0x32>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a0378:	6800      	ldr	r0, [r0, #0]
 80a037a:	f7ff fe89 	bl	80a0090 <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a037e:	2000      	movs	r0, #0
 80a0380:	bd38      	pop	{r3, r4, r5, pc}
	...

080a0384 <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3>:
    static bool function(const char *funcKey, user_function_int_str_t* func)
    {
        return CLOUD_FN(register_function(call_raw_user_function, (void*)func, funcKey), false);
    }

    static bool function(const char *funcKey, user_std_function_int_str_t func, void* reserved=NULL)
 80a0384:	b570      	push	{r4, r5, r6, lr}
    {
#ifdef SPARK_NO_CLOUD
        return false;
#else
        bool success = false;
        if (func) // if the call-wrapper has wrapped a callable object
 80a0386:	688b      	ldr	r3, [r1, #8]
    static bool function(const char *funcKey, user_function_int_str_t* func)
    {
        return CLOUD_FN(register_function(call_raw_user_function, (void*)func, funcKey), false);
    }

    static bool function(const char *funcKey, user_std_function_int_str_t func, void* reserved=NULL)
 80a0388:	4606      	mov	r6, r0
 80a038a:	460c      	mov	r4, r1
    {
#ifdef SPARK_NO_CLOUD
        return false;
#else
        bool success = false;
        if (func) // if the call-wrapper has wrapped a callable object
 80a038c:	b1b3      	cbz	r3, 80a03bc <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3+0x38>
        {
            auto wrapper = new user_std_function_int_str_t(func);
 80a038e:	2010      	movs	r0, #16
 80a0390:	f7ff fe7c 	bl	80a008c <_Znwj>
 80a0394:	4605      	mov	r5, r0
 80a0396:	b188      	cbz	r0, 80a03bc <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3+0x38>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(0) { }
 80a0398:	2300      	movs	r3, #0
 80a039a:	6083      	str	r3, [r0, #8]
 80a039c:	68a3      	ldr	r3, [r4, #8]
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a039e:	b133      	cbz	r3, 80a03ae <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3+0x2a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a03a0:	4621      	mov	r1, r4
 80a03a2:	2202      	movs	r2, #2
 80a03a4:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a03a6:	68e3      	ldr	r3, [r4, #12]
 80a03a8:	60eb      	str	r3, [r5, #12]
	  _M_manager = __x._M_manager;
 80a03aa:	68a3      	ldr	r3, [r4, #8]
 80a03ac:	60ab      	str	r3, [r5, #8]
            if (wrapper) {
                success = register_function(call_std_user_function, wrapper, funcKey);
 80a03ae:	4629      	mov	r1, r5
 80a03b0:	4632      	mov	r2, r6
            }
        }
        return success;
#endif
    }
 80a03b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        bool success = false;
        if (func) // if the call-wrapper has wrapped a callable object
        {
            auto wrapper = new user_std_function_int_str_t(func);
            if (wrapper) {
                success = register_function(call_std_user_function, wrapper, funcKey);
 80a03b6:	4802      	ldr	r0, [pc, #8]	; (80a03c0 <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3+0x3c>)
 80a03b8:	f000 bc6f 	b.w	80a0c9a <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>
            }
        }
        return success;
#endif
    }
 80a03bc:	2000      	movs	r0, #0
 80a03be:	bd70      	pop	{r4, r5, r6, pc}
 80a03c0:	080a0c63 	.word	0x080a0c63

080a03c4 <_ZNSt17_Function_handlerIFi6StringESt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS4_St12_PlaceholderILi1EEEEE9_M_invokeERKSt9_Any_dataS0_>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
 80a03c4:	b530      	push	{r4, r5, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a03c6:	6802      	ldr	r2, [r0, #0]
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
 80a03c8:	b085      	sub	sp, #20

      // Handle pointers
      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
	_Res
	operator()(_Class* __object, _Args&&... __args) const
	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
 80a03ca:	6853      	ldr	r3, [r2, #4]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (get<_Indexes>(_M_bound_args), __args)...);
 80a03cc:	6894      	ldr	r4, [r2, #8]

      // Handle pointers
      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
	_Res
	operator()(_Class* __object, _Args&&... __args) const
	{ return (__object->*__pmf)(std::forward<_Args>(__args)...); }
 80a03ce:	f013 0f01 	tst.w	r3, #1
 80a03d2:	ea4f 0363 	mov.w	r3, r3, asr #1
 80a03d6:	6815      	ldr	r5, [r2, #0]
 80a03d8:	bf18      	it	ne
 80a03da:	58e2      	ldrne	r2, [r4, r3]
 80a03dc:	4668      	mov	r0, sp
 80a03de:	441c      	add	r4, r3
 80a03e0:	bf18      	it	ne
 80a03e2:	5955      	ldrne	r5, [r2, r5]
 80a03e4:	f000 fdfd 	bl	80a0fe2 <_ZN6StringC1EOS_>
 80a03e8:	4669      	mov	r1, sp
 80a03ea:	4620      	mov	r0, r4
 80a03ec:	47a8      	blx	r5
 80a03ee:	4604      	mov	r4, r0
 80a03f0:	4668      	mov	r0, sp
 80a03f2:	f000 fe06 	bl	80a1002 <_ZN6StringD1Ev>
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
	return (*_Base::_M_get_pointer(__functor))(
	    std::forward<_ArgTypes>(__args)...);
      }
 80a03f6:	4620      	mov	r0, r4
 80a03f8:	b005      	add	sp, #20
 80a03fa:	bd30      	pop	{r4, r5, pc}

080a03fc <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
 80a03fc:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a03fe:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
 80a0400:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a0402:	b113      	cbz	r3, 80a040a <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0404:	4601      	mov	r1, r0
 80a0406:	2203      	movs	r2, #3
 80a0408:	4798      	blx	r3
    }
 80a040a:	4620      	mov	r0, r4
 80a040c:	bd10      	pop	{r4, pc}

080a040e <_ZN8sparkbotC1Ev>:


sparkbot::sparkbot()
{
  // 3 Servo angles
  neckAngle = 0;
 80a040e:	2200      	movs	r2, #0
 80a0410:	6002      	str	r2, [r0, #0]
  rightArmAngle = 0;
 80a0412:	6042      	str	r2, [r0, #4]
  leftArmAngle = 0;
 80a0414:	6082      	str	r2, [r0, #8]

  redValue = 0;
 80a0416:	6102      	str	r2, [r0, #16]
  greenValue = 0;
 80a0418:	6142      	str	r2, [r0, #20]
  blueValue = 0;
 80a041a:	6182      	str	r2, [r0, #24]

  choice = 0; // Used for switching lights
 80a041c:	61c2      	str	r2, [r0, #28]

  slaveMode = false;
 80a041e:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
}
 80a0422:	4770      	bx	lr

080a0424 <_ZN8sparkbot3redEv>:
    return;
  }
}

void sparkbot::red() //This function turns on the red, and turns off the blue and green
{
 80a0424:	b538      	push	{r3, r4, r5, lr}
 80a0426:	4604      	mov	r4, r0
  analogWrite(REDLED, 255);
 80a0428:	21ff      	movs	r1, #255	; 0xff
 80a042a:	2003      	movs	r0, #3
 80a042c:	f001 f80e 	bl	80a144c <analogWrite>
  redValue = 255;
 80a0430:	23ff      	movs	r3, #255	; 0xff
  analogWrite(BLUELED, 0);
  blueValue = 0;
 80a0432:	2500      	movs	r5, #0
}

void sparkbot::red() //This function turns on the red, and turns off the blue and green
{
  analogWrite(REDLED, 255);
  redValue = 255;
 80a0434:	6123      	str	r3, [r4, #16]
  analogWrite(BLUELED, 0);
 80a0436:	2011      	movs	r0, #17
 80a0438:	2100      	movs	r1, #0
 80a043a:	f001 f807 	bl	80a144c <analogWrite>
  blueValue = 0;
 80a043e:	61a5      	str	r5, [r4, #24]
  analogWrite(GREENLED, 0);
 80a0440:	2013      	movs	r0, #19
 80a0442:	4629      	mov	r1, r5
 80a0444:	f001 f802 	bl	80a144c <analogWrite>
  greenValue = 0;
 80a0448:	6165      	str	r5, [r4, #20]
 80a044a:	bd38      	pop	{r3, r4, r5, pc}

080a044c <_ZN8sparkbot4blueEv>:
}

void sparkbot::blue() //This function turns on the blue, and turns off the red and green
{
 80a044c:	b538      	push	{r3, r4, r5, lr}
 80a044e:	4605      	mov	r5, r0
  analogWrite(REDLED, 0);
  redValue = 0;
 80a0450:	2400      	movs	r4, #0
  greenValue = 0;
}

void sparkbot::blue() //This function turns on the blue, and turns off the red and green
{
  analogWrite(REDLED, 0);
 80a0452:	2003      	movs	r0, #3
 80a0454:	2100      	movs	r1, #0
 80a0456:	f000 fff9 	bl	80a144c <analogWrite>
  redValue = 0;
  analogWrite(BLUELED, 255);
 80a045a:	2011      	movs	r0, #17
 80a045c:	21ff      	movs	r1, #255	; 0xff
}

void sparkbot::blue() //This function turns on the blue, and turns off the red and green
{
  analogWrite(REDLED, 0);
  redValue = 0;
 80a045e:	612c      	str	r4, [r5, #16]
  analogWrite(BLUELED, 255);
 80a0460:	f000 fff4 	bl	80a144c <analogWrite>
  blueValue = 0;
 80a0464:	61ac      	str	r4, [r5, #24]
  analogWrite(GREENLED, 0);
 80a0466:	2013      	movs	r0, #19
 80a0468:	4621      	mov	r1, r4
 80a046a:	f000 ffef 	bl	80a144c <analogWrite>
  greenValue = 0;
 80a046e:	616c      	str	r4, [r5, #20]
 80a0470:	bd38      	pop	{r3, r4, r5, pc}

080a0472 <_ZN8sparkbot5greenEv>:
}

void sparkbot::green() //This function turns on the green, and turns off the red and blue
{
 80a0472:	b538      	push	{r3, r4, r5, lr}
 80a0474:	4604      	mov	r4, r0
  analogWrite(REDLED, 0);
  redValue = 0;
 80a0476:	2500      	movs	r5, #0
  greenValue = 0;
}

void sparkbot::green() //This function turns on the green, and turns off the red and blue
{
  analogWrite(REDLED, 0);
 80a0478:	2003      	movs	r0, #3
 80a047a:	2100      	movs	r1, #0
 80a047c:	f000 ffe6 	bl	80a144c <analogWrite>
  redValue = 0;
  analogWrite(BLUELED, 0);
 80a0480:	2011      	movs	r0, #17
 80a0482:	4629      	mov	r1, r5
}

void sparkbot::green() //This function turns on the green, and turns off the red and blue
{
  analogWrite(REDLED, 0);
  redValue = 0;
 80a0484:	6125      	str	r5, [r4, #16]
  analogWrite(BLUELED, 0);
 80a0486:	f000 ffe1 	bl	80a144c <analogWrite>
  blueValue = 0;
 80a048a:	61a5      	str	r5, [r4, #24]
  analogWrite(GREENLED, 255);
 80a048c:	2013      	movs	r0, #19
 80a048e:	21ff      	movs	r1, #255	; 0xff
 80a0490:	f000 ffdc 	bl	80a144c <analogWrite>
  greenValue = 255;
 80a0494:	23ff      	movs	r3, #255	; 0xff
 80a0496:	6163      	str	r3, [r4, #20]
 80a0498:	bd38      	pop	{r3, r4, r5, pc}
	...

080a049c <_ZN8sparkbot8moveNeckEi>:
  syncLights();
  syncServos();
}

void sparkbot::moveNeck(int value)
{
 80a049c:	b508      	push	{r3, lr}
  neckservo.write(value);
 80a049e:	4804      	ldr	r0, [pc, #16]	; (80a04b0 <_ZN8sparkbot8moveNeckEi+0x14>)
 80a04a0:	f000 fd1c 	bl	80a0edc <_ZN5Servo5writeEi>
  delay(15);
}
 80a04a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void sparkbot::moveNeck(int value)
{
  neckservo.write(value);
  delay(15);
 80a04a8:	200f      	movs	r0, #15
 80a04aa:	f000 bbd7 	b.w	80a0c5c <delay>
 80a04ae:	bf00      	nop
 80a04b0:	2000039c 	.word	0x2000039c

080a04b4 <_ZN8sparkbot9moveRightEi>:
}

void sparkbot::moveRight(int value)
{
 80a04b4:	b508      	push	{r3, lr}
  rightservo.write(value);
 80a04b6:	4804      	ldr	r0, [pc, #16]	; (80a04c8 <_ZN8sparkbot9moveRightEi+0x14>)
 80a04b8:	f000 fd10 	bl	80a0edc <_ZN5Servo5writeEi>
  delay(15);
}
 80a04bc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void sparkbot::moveRight(int value)
{
  rightservo.write(value);
  delay(15);
 80a04c0:	200f      	movs	r0, #15
 80a04c2:	f000 bbcb 	b.w	80a0c5c <delay>
 80a04c6:	bf00      	nop
 80a04c8:	200003b0 	.word	0x200003b0

080a04cc <_ZN8sparkbot8moveLeftEi>:
}

void sparkbot::moveLeft(int value)
{
 80a04cc:	b508      	push	{r3, lr}
  leftservo.write(value);
 80a04ce:	4804      	ldr	r0, [pc, #16]	; (80a04e0 <_ZN8sparkbot8moveLeftEi+0x14>)
 80a04d0:	f000 fd04 	bl	80a0edc <_ZN5Servo5writeEi>
  delay(15);
}
 80a04d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

void sparkbot::moveLeft(int value)
{
  leftservo.write(value);
  delay(15);
 80a04d8:	200f      	movs	r0, #15
 80a04da:	f000 bbbf 	b.w	80a0c5c <delay>
 80a04de:	bf00      	nop
 80a04e0:	200003c0 	.word	0x200003c0

080a04e4 <_ZN8sparkbot9moveCloudE6String>:
{
  analogWrite(BUZZER, 0);
}

int sparkbot::moveCloud(String data)
{
 80a04e4:	b530      	push	{r4, r5, lr}
 80a04e6:	460c      	mov	r4, r1
 80a04e8:	b095      	sub	sp, #84	; 0x54
  String neckvalue = data.substring(0, 3);
 80a04ea:	2200      	movs	r2, #0
 80a04ec:	2303      	movs	r3, #3
{
  analogWrite(BUZZER, 0);
}

int sparkbot::moveCloud(String data)
{
 80a04ee:	4605      	mov	r5, r0
  String neckvalue = data.substring(0, 3);
 80a04f0:	4668      	mov	r0, sp
 80a04f2:	f000 fe23 	bl	80a113c <_ZNK6String9substringEjj>
  String rightvalue = data.substring(4, 7);
 80a04f6:	a804      	add	r0, sp, #16
 80a04f8:	4621      	mov	r1, r4
 80a04fa:	2204      	movs	r2, #4
 80a04fc:	2307      	movs	r3, #7
 80a04fe:	f000 fe1d 	bl	80a113c <_ZNK6String9substringEjj>
  String leftvalue = data.substring(8,11);
 80a0502:	a808      	add	r0, sp, #32
 80a0504:	4621      	mov	r1, r4
 80a0506:	2208      	movs	r2, #8
 80a0508:	230b      	movs	r3, #11
 80a050a:	f000 fe17 	bl	80a113c <_ZNK6String9substringEjj>

  if (neckvalue.toInt() != 200)
 80a050e:	4668      	mov	r0, sp
 80a0510:	f000 fe3c 	bl	80a118c <_ZNK6String5toIntEv>
 80a0514:	28c8      	cmp	r0, #200	; 0xc8
 80a0516:	d006      	beq.n	80a0526 <_ZN8sparkbot9moveCloudE6String+0x42>
  {
    moveNeck(neckvalue.toInt());
 80a0518:	4668      	mov	r0, sp
 80a051a:	f000 fe37 	bl	80a118c <_ZNK6String5toIntEv>
 80a051e:	4601      	mov	r1, r0
 80a0520:	4628      	mov	r0, r5
 80a0522:	f7ff ffbb 	bl	80a049c <_ZN8sparkbot8moveNeckEi>
  }
  if (rightvalue.toInt() != 200)
 80a0526:	a804      	add	r0, sp, #16
 80a0528:	f000 fe30 	bl	80a118c <_ZNK6String5toIntEv>
 80a052c:	28c8      	cmp	r0, #200	; 0xc8
 80a052e:	d006      	beq.n	80a053e <_ZN8sparkbot9moveCloudE6String+0x5a>
  {
    moveRight(rightvalue.toInt());
 80a0530:	a804      	add	r0, sp, #16
 80a0532:	f000 fe2b 	bl	80a118c <_ZNK6String5toIntEv>
 80a0536:	4601      	mov	r1, r0
 80a0538:	4628      	mov	r0, r5
 80a053a:	f7ff ffbb 	bl	80a04b4 <_ZN8sparkbot9moveRightEi>
  }
  if (leftvalue.toInt() != 200)
 80a053e:	a808      	add	r0, sp, #32
 80a0540:	f000 fe24 	bl	80a118c <_ZNK6String5toIntEv>
 80a0544:	28c8      	cmp	r0, #200	; 0xc8
 80a0546:	d006      	beq.n	80a0556 <_ZN8sparkbot9moveCloudE6String+0x72>
  {
    moveLeft(leftvalue.toInt());
 80a0548:	a808      	add	r0, sp, #32
 80a054a:	f000 fe1f 	bl	80a118c <_ZNK6String5toIntEv>
 80a054e:	4601      	mov	r1, r0
 80a0550:	4628      	mov	r0, r5
 80a0552:	f7ff ffbb 	bl	80a04cc <_ZN8sparkbot8moveLeftEi>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0556:	a810      	add	r0, sp, #64	; 0x40
 80a0558:	4935      	ldr	r1, [pc, #212]	; (80a0630 <_ZN8sparkbot9moveCloudE6String+0x14c>)
 80a055a:	f000 fd94 	bl	80a1086 <_ZN6StringC1EPKc>
  }

  Serial.println("Original String: " + data);
 80a055e:	4621      	mov	r1, r4
 80a0560:	a810      	add	r0, sp, #64	; 0x40
 80a0562:	f000 fdde 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a0566:	4603      	mov	r3, r0
 80a0568:	4832      	ldr	r0, [pc, #200]	; (80a0634 <_ZN8sparkbot9moveCloudE6String+0x150>)
 80a056a:	6819      	ldr	r1, [r3, #0]
 80a056c:	f000 fc6d 	bl	80a0e4a <_ZN5Print7printlnEPKc>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0570:	a810      	add	r0, sp, #64	; 0x40
 80a0572:	f000 fd46 	bl	80a1002 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0576:	4930      	ldr	r1, [pc, #192]	; (80a0638 <_ZN8sparkbot9moveCloudE6String+0x154>)
 80a0578:	a810      	add	r0, sp, #64	; 0x40
 80a057a:	f000 fd84 	bl	80a1086 <_ZN6StringC1EPKc>
  Serial.println("Neck: " + String(neckvalue.toInt()));
 80a057e:	4668      	mov	r0, sp
 80a0580:	f000 fe04 	bl	80a118c <_ZNK6String5toIntEv>
 80a0584:	220a      	movs	r2, #10
 80a0586:	4601      	mov	r1, r0
 80a0588:	a80c      	add	r0, sp, #48	; 0x30
 80a058a:	f000 fda0 	bl	80a10ce <_ZN6StringC1Elh>
 80a058e:	a90c      	add	r1, sp, #48	; 0x30
 80a0590:	a810      	add	r0, sp, #64	; 0x40
 80a0592:	f000 fdc6 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a0596:	4603      	mov	r3, r0
 80a0598:	4826      	ldr	r0, [pc, #152]	; (80a0634 <_ZN8sparkbot9moveCloudE6String+0x150>)
 80a059a:	6819      	ldr	r1, [r3, #0]
 80a059c:	f000 fc55 	bl	80a0e4a <_ZN5Print7printlnEPKc>
 80a05a0:	a80c      	add	r0, sp, #48	; 0x30
 80a05a2:	f000 fd2e 	bl	80a1002 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a05a6:	a810      	add	r0, sp, #64	; 0x40
 80a05a8:	f000 fd2b 	bl	80a1002 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a05ac:	4923      	ldr	r1, [pc, #140]	; (80a063c <_ZN8sparkbot9moveCloudE6String+0x158>)
 80a05ae:	a810      	add	r0, sp, #64	; 0x40
 80a05b0:	f000 fd69 	bl	80a1086 <_ZN6StringC1EPKc>
  Serial.println("Right: " + String(rightvalue.toInt()));
 80a05b4:	a804      	add	r0, sp, #16
 80a05b6:	f000 fde9 	bl	80a118c <_ZNK6String5toIntEv>
 80a05ba:	220a      	movs	r2, #10
 80a05bc:	4601      	mov	r1, r0
 80a05be:	a80c      	add	r0, sp, #48	; 0x30
 80a05c0:	f000 fd85 	bl	80a10ce <_ZN6StringC1Elh>
 80a05c4:	a90c      	add	r1, sp, #48	; 0x30
 80a05c6:	a810      	add	r0, sp, #64	; 0x40
 80a05c8:	f000 fdab 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a05cc:	4603      	mov	r3, r0
 80a05ce:	4819      	ldr	r0, [pc, #100]	; (80a0634 <_ZN8sparkbot9moveCloudE6String+0x150>)
 80a05d0:	6819      	ldr	r1, [r3, #0]
 80a05d2:	f000 fc3a 	bl	80a0e4a <_ZN5Print7printlnEPKc>
 80a05d6:	a80c      	add	r0, sp, #48	; 0x30
 80a05d8:	f000 fd13 	bl	80a1002 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a05dc:	a810      	add	r0, sp, #64	; 0x40
 80a05de:	f000 fd10 	bl	80a1002 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a05e2:	4917      	ldr	r1, [pc, #92]	; (80a0640 <_ZN8sparkbot9moveCloudE6String+0x15c>)
 80a05e4:	a810      	add	r0, sp, #64	; 0x40
 80a05e6:	f000 fd4e 	bl	80a1086 <_ZN6StringC1EPKc>
  Serial.println("Left: " + String(leftvalue.toInt()));
 80a05ea:	a808      	add	r0, sp, #32
 80a05ec:	f000 fdce 	bl	80a118c <_ZNK6String5toIntEv>
 80a05f0:	220a      	movs	r2, #10
 80a05f2:	4601      	mov	r1, r0
 80a05f4:	a80c      	add	r0, sp, #48	; 0x30
 80a05f6:	f000 fd6a 	bl	80a10ce <_ZN6StringC1Elh>
 80a05fa:	a90c      	add	r1, sp, #48	; 0x30
 80a05fc:	a810      	add	r0, sp, #64	; 0x40
 80a05fe:	f000 fd90 	bl	80a1122 <_ZplRK15StringSumHelperRK6String>
 80a0602:	4603      	mov	r3, r0
 80a0604:	480b      	ldr	r0, [pc, #44]	; (80a0634 <_ZN8sparkbot9moveCloudE6String+0x150>)
 80a0606:	6819      	ldr	r1, [r3, #0]
 80a0608:	f000 fc1f 	bl	80a0e4a <_ZN5Print7printlnEPKc>
 80a060c:	a80c      	add	r0, sp, #48	; 0x30
 80a060e:	f000 fcf8 	bl	80a1002 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0612:	a810      	add	r0, sp, #64	; 0x40
 80a0614:	f000 fcf5 	bl	80a1002 <_ZN6StringD1Ev>

int sparkbot::moveCloud(String data)
{
  String neckvalue = data.substring(0, 3);
  String rightvalue = data.substring(4, 7);
  String leftvalue = data.substring(8,11);
 80a0618:	a808      	add	r0, sp, #32
 80a061a:	f000 fcf2 	bl	80a1002 <_ZN6StringD1Ev>
}

int sparkbot::moveCloud(String data)
{
  String neckvalue = data.substring(0, 3);
  String rightvalue = data.substring(4, 7);
 80a061e:	a804      	add	r0, sp, #16
 80a0620:	f000 fcef 	bl	80a1002 <_ZN6StringD1Ev>

  Serial.println("Original String: " + data);
  Serial.println("Neck: " + String(neckvalue.toInt()));
  Serial.println("Right: " + String(rightvalue.toInt()));
  Serial.println("Left: " + String(leftvalue.toInt()));
  return 1;
 80a0624:	4668      	mov	r0, sp
 80a0626:	f000 fcec 	bl	80a1002 <_ZN6StringD1Ev>
}
 80a062a:	2001      	movs	r0, #1
 80a062c:	b015      	add	sp, #84	; 0x54
 80a062e:	bd30      	pop	{r4, r5, pc}
 80a0630:	080a1927 	.word	0x080a1927
 80a0634:	2000046c 	.word	0x2000046c
 80a0638:	080a1939 	.word	0x080a1939
 80a063c:	080a1940 	.word	0x080a1940
 80a0640:	080a1948 	.word	0x080a1948

080a0644 <_ZN8sparkbot15syncServosSlaveEPKcS1_>:
  return -1;

}

void sparkbot::syncServosSlave(const char *event, const char *data)
{
 80a0644:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (slaveMode == false) {return;}
 80a0646:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
  return -1;

}

void sparkbot::syncServosSlave(const char *event, const char *data)
{
 80a064a:	b091      	sub	sp, #68	; 0x44
 80a064c:	4604      	mov	r4, r0
  if (slaveMode == false) {return;}
 80a064e:	2b00      	cmp	r3, #0
 80a0650:	d061      	beq.n	80a0716 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xd2>

  String message = String(data);
 80a0652:	4611      	mov	r1, r2
 80a0654:	4668      	mov	r0, sp
 80a0656:	f000 fd16 	bl	80a1086 <_ZN6StringC1EPKc>

  String neckresult = message.substring(0, 3);
 80a065a:	a804      	add	r0, sp, #16
 80a065c:	4669      	mov	r1, sp
 80a065e:	2200      	movs	r2, #0
 80a0660:	2303      	movs	r3, #3
 80a0662:	f000 fd6b 	bl	80a113c <_ZNK6String9substringEjj>
  String rightresult = message.substring(3, 6);
 80a0666:	a808      	add	r0, sp, #32
 80a0668:	4669      	mov	r1, sp
 80a066a:	2203      	movs	r2, #3
 80a066c:	2306      	movs	r3, #6
 80a066e:	f000 fd65 	bl	80a113c <_ZNK6String9substringEjj>
  String leftresult = message.substring(6,9);
 80a0672:	a80c      	add	r0, sp, #48	; 0x30
 80a0674:	4669      	mov	r1, sp
 80a0676:	2206      	movs	r2, #6
 80a0678:	2309      	movs	r3, #9
 80a067a:	f000 fd5f 	bl	80a113c <_ZNK6String9substringEjj>

  bool moveNeck = false;
  bool moveRight = false;
  bool moveLeft = false;

  if (neckresult.toInt() >= 0 && neckresult.toInt() <= 180)
 80a067e:	a804      	add	r0, sp, #16
 80a0680:	f000 fd84 	bl	80a118c <_ZNK6String5toIntEv>
 80a0684:	2800      	cmp	r0, #0
 80a0686:	db40      	blt.n	80a070a <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xc6>
 80a0688:	a804      	add	r0, sp, #16
 80a068a:	f000 fd7f 	bl	80a118c <_ZNK6String5toIntEv>
 80a068e:	28b4      	cmp	r0, #180	; 0xb4
 80a0690:	dc3b      	bgt.n	80a070a <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xc6>
  {
    moveNeck = true;
 80a0692:	2601      	movs	r6, #1
  }

  if (rightresult.toInt() >= 0 && rightresult.toInt() <= 180)
 80a0694:	a808      	add	r0, sp, #32
 80a0696:	f000 fd79 	bl	80a118c <_ZNK6String5toIntEv>
 80a069a:	2800      	cmp	r0, #0
 80a069c:	db37      	blt.n	80a070e <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xca>
 80a069e:	a808      	add	r0, sp, #32
 80a06a0:	f000 fd74 	bl	80a118c <_ZNK6String5toIntEv>
 80a06a4:	28b4      	cmp	r0, #180	; 0xb4
 80a06a6:	dc32      	bgt.n	80a070e <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xca>
  {
    moveRight = true;
 80a06a8:	2701      	movs	r7, #1
  }

  if (leftresult.toInt() >= 0 && leftresult.toInt() <= 180)
 80a06aa:	a80c      	add	r0, sp, #48	; 0x30
 80a06ac:	f000 fd6e 	bl	80a118c <_ZNK6String5toIntEv>
 80a06b0:	2800      	cmp	r0, #0
 80a06b2:	db2e      	blt.n	80a0712 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xce>
 80a06b4:	a80c      	add	r0, sp, #48	; 0x30
 80a06b6:	f000 fd69 	bl	80a118c <_ZNK6String5toIntEv>
 80a06ba:	28b4      	cmp	r0, #180	; 0xb4
 80a06bc:	dc29      	bgt.n	80a0712 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xce>
  {
    moveLeft = true;
 80a06be:	2501      	movs	r5, #1
  }


  if (moveNeck == true)
 80a06c0:	b136      	cbz	r6, 80a06d0 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0x8c>
  {
    sparkbot::moveNeck(neckresult.toInt());
 80a06c2:	a804      	add	r0, sp, #16
 80a06c4:	f000 fd62 	bl	80a118c <_ZNK6String5toIntEv>
 80a06c8:	4601      	mov	r1, r0
 80a06ca:	4620      	mov	r0, r4
 80a06cc:	f7ff fee6 	bl	80a049c <_ZN8sparkbot8moveNeckEi>
  }

  if (moveRight == true)
 80a06d0:	b137      	cbz	r7, 80a06e0 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0x9c>
  {
    sparkbot::moveRight(rightresult.toInt());
 80a06d2:	a808      	add	r0, sp, #32
 80a06d4:	f000 fd5a 	bl	80a118c <_ZNK6String5toIntEv>
 80a06d8:	4601      	mov	r1, r0
 80a06da:	4620      	mov	r0, r4
 80a06dc:	f7ff feea 	bl	80a04b4 <_ZN8sparkbot9moveRightEi>
  }

  if (moveLeft == true)
 80a06e0:	b135      	cbz	r5, 80a06f0 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xac>
  {
    sparkbot::moveLeft(leftresult.toInt());
 80a06e2:	a80c      	add	r0, sp, #48	; 0x30
 80a06e4:	f000 fd52 	bl	80a118c <_ZNK6String5toIntEv>
 80a06e8:	4601      	mov	r1, r0
 80a06ea:	4620      	mov	r0, r4
 80a06ec:	f7ff feee 	bl	80a04cc <_ZN8sparkbot8moveLeftEi>

  String message = String(data);

  String neckresult = message.substring(0, 3);
  String rightresult = message.substring(3, 6);
  String leftresult = message.substring(6,9);
 80a06f0:	a80c      	add	r0, sp, #48	; 0x30
 80a06f2:	f000 fc86 	bl	80a1002 <_ZN6StringD1Ev>
  if (slaveMode == false) {return;}

  String message = String(data);

  String neckresult = message.substring(0, 3);
  String rightresult = message.substring(3, 6);
 80a06f6:	a808      	add	r0, sp, #32
 80a06f8:	f000 fc83 	bl	80a1002 <_ZN6StringD1Ev>
{
  if (slaveMode == false) {return;}

  String message = String(data);

  String neckresult = message.substring(0, 3);
 80a06fc:	a804      	add	r0, sp, #16
 80a06fe:	f000 fc80 	bl	80a1002 <_ZN6StringD1Ev>
  }

  if (moveLeft == true)
  {
    sparkbot::moveLeft(leftresult.toInt());
  }
 80a0702:	4668      	mov	r0, sp
 80a0704:	f000 fc7d 	bl	80a1002 <_ZN6StringD1Ev>
 80a0708:	e005      	b.n	80a0716 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0xd2>

  String neckresult = message.substring(0, 3);
  String rightresult = message.substring(3, 6);
  String leftresult = message.substring(6,9);

  bool moveNeck = false;
 80a070a:	2600      	movs	r6, #0
 80a070c:	e7c2      	b.n	80a0694 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0x50>
  bool moveRight = false;
 80a070e:	2700      	movs	r7, #0
 80a0710:	e7cb      	b.n	80a06aa <_ZN8sparkbot15syncServosSlaveEPKcS1_+0x66>
  bool moveLeft = false;
 80a0712:	2500      	movs	r5, #0
 80a0714:	e7d4      	b.n	80a06c0 <_ZN8sparkbot15syncServosSlaveEPKcS1_+0x7c>

  if (moveLeft == true)
  {
    sparkbot::moveLeft(leftresult.toInt());
  }
}
 80a0716:	b011      	add	sp, #68	; 0x44
 80a0718:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a071c <_ZN8sparkbot8RGBSlaveEPKcS1_>:

void sparkbot::RGBSlave(const char *event, const char *data)
{
 80a071c:	b538      	push	{r3, r4, r5, lr}
  if (slaveMode == false) {return;}
 80a071e:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
    sparkbot::moveLeft(leftresult.toInt());
  }
}

void sparkbot::RGBSlave(const char *event, const char *data)
{
 80a0722:	4604      	mov	r4, r0
 80a0724:	4615      	mov	r5, r2
  if (slaveMode == false) {return;}
 80a0726:	b1cb      	cbz	r3, 80a075c <_ZN8sparkbot8RGBSlaveEPKcS1_+0x40>

  if (strcmp(data, "red") == 0)
 80a0728:	4610      	mov	r0, r2
 80a072a:	490d      	ldr	r1, [pc, #52]	; (80a0760 <_ZN8sparkbot8RGBSlaveEPKcS1_+0x44>)
 80a072c:	f001 f80f 	bl	80a174e <strcmp>
 80a0730:	b910      	cbnz	r0, 80a0738 <_ZN8sparkbot8RGBSlaveEPKcS1_+0x1c>
  {
    red();
 80a0732:	4620      	mov	r0, r4
 80a0734:	f7ff fe76 	bl	80a0424 <_ZN8sparkbot3redEv>
  }

  if (strcmp(data, "blue") == 0)
 80a0738:	4628      	mov	r0, r5
 80a073a:	490a      	ldr	r1, [pc, #40]	; (80a0764 <_ZN8sparkbot8RGBSlaveEPKcS1_+0x48>)
 80a073c:	f001 f807 	bl	80a174e <strcmp>
 80a0740:	b910      	cbnz	r0, 80a0748 <_ZN8sparkbot8RGBSlaveEPKcS1_+0x2c>
  {
    blue();
 80a0742:	4620      	mov	r0, r4
 80a0744:	f7ff fe82 	bl	80a044c <_ZN8sparkbot4blueEv>
  }

  if (strcmp(data, "green") == 0)
 80a0748:	4628      	mov	r0, r5
 80a074a:	4907      	ldr	r1, [pc, #28]	; (80a0768 <_ZN8sparkbot8RGBSlaveEPKcS1_+0x4c>)
 80a074c:	f000 ffff 	bl	80a174e <strcmp>
 80a0750:	b920      	cbnz	r0, 80a075c <_ZN8sparkbot8RGBSlaveEPKcS1_+0x40>
  {
    green();
 80a0752:	4620      	mov	r0, r4
  }
}
 80a0754:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    blue();
  }

  if (strcmp(data, "green") == 0)
  {
    green();
 80a0758:	f7ff be8b 	b.w	80a0472 <_ZN8sparkbot5greenEv>
 80a075c:	bd38      	pop	{r3, r4, r5, pc}
 80a075e:	bf00      	nop
 80a0760:	080a1914 	.word	0x080a1914
 80a0764:	080a1918 	.word	0x080a1918
 80a0768:	080a191d 	.word	0x080a191d

080a076c <_ZN8sparkbot13getNoiseLevelEv>:
{
  return analogRead(PHOTORESISTOR);
}

int sparkbot::getNoiseLevel()
{
 80a076c:	b508      	push	{r3, lr}
  return analogRead(MICROPHONE) / 4;
 80a076e:	200d      	movs	r0, #13
 80a0770:	f000 fe55 	bl	80a141e <analogRead>
}
 80a0774:	2304      	movs	r3, #4
 80a0776:	fb90 f0f3 	sdiv	r0, r0, r3
 80a077a:	bd08      	pop	{r3, pc}

080a077c <_ZN8sparkbot7refreshEv>:
void sparkbot::refresh()
{
 80a077c:	b510      	push	{r4, lr}
 80a077e:	4604      	mov	r4, r0
  return tempC;
}

int sparkbot::lightness()
{
  return analogRead(PHOTORESISTOR);
 80a0780:	200a      	movs	r0, #10
 80a0782:	f000 fe4c 	bl	80a141e <analogRead>
{
  return analogRead(MICROPHONE) / 4;
}
void sparkbot::refresh()
{
  brightness = lightness();
 80a0786:	60e0      	str	r0, [r4, #12]
  noiseLevel = getNoiseLevel();
 80a0788:	4620      	mov	r0, r4
 80a078a:	f7ff ffef 	bl	80a076c <_ZN8sparkbot13getNoiseLevelEv>
 80a078e:	6220      	str	r0, [r4, #32]
 80a0790:	bd10      	pop	{r4, pc}
	...

080a0794 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_>:
	}
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename>
      function<_Res(_ArgTypes...)>::
 80a0794:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(0) { }
 80a0796:	2300      	movs	r3, #0
 80a0798:	6083      	str	r3, [r0, #8]
	}
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename>
      function<_Res(_ArgTypes...)>::
 80a079a:	4604      	mov	r4, r0
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a079c:	200c      	movs	r0, #12
	}
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename>
      function<_Res(_ArgTypes...)>::
 80a079e:	460d      	mov	r5, r1
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a07a0:	f7ff fc74 	bl	80a008c <_Znwj>
 80a07a4:	4603      	mov	r3, r0
 80a07a6:	b128      	cbz	r0, 80a07b4 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_+0x20>
	{ }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
 80a07a8:	e895 0003 	ldmia.w	r5, {r0, r1}
 80a07ac:	e883 0003 	stmia.w	r3, {r0, r1}
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a07b0:	68aa      	ldr	r2, [r5, #8]
 80a07b2:	609a      	str	r2, [r3, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a07b4:	6023      	str	r3, [r4, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a07b6:	4b03      	ldr	r3, [pc, #12]	; (80a07c4 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_+0x30>)
	    _M_manager = &_My_handler::_M_manager;
	  }
      }
 80a07b8:	4620      	mov	r0, r4
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a07ba:	60e3      	str	r3, [r4, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a07bc:	4b02      	ldr	r3, [pc, #8]	; (80a07c8 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_+0x34>)
 80a07be:	60a3      	str	r3, [r4, #8]
	  }
      }
 80a07c0:	bd38      	pop	{r3, r4, r5, pc}
 80a07c2:	bf00      	nop
 80a07c4:	080a03c5 	.word	0x080a03c5
 80a07c8:	080a034d 	.word	0x080a034d

080a07cc <_ZN8sparkbot5beginEv>:

  slaveMode = false;
}

void sparkbot::begin()
{
 80a07cc:	b570      	push	{r4, r5, r6, lr}
 80a07ce:	4605      	mov	r5, r0
 80a07d0:	b090      	sub	sp, #64	; 0x40
  neckservo.attach(NECKSERVO);
 80a07d2:	2400      	movs	r4, #0
 80a07d4:	26b4      	movs	r6, #180	; 0xb4
 80a07d6:	e88d 0050 	stmia.w	sp, {r4, r6}
 80a07da:	2102      	movs	r1, #2
 80a07dc:	f44f 7208 	mov.w	r2, #544	; 0x220
 80a07e0:	f44f 6316 	mov.w	r3, #2400	; 0x960
 80a07e4:	4840      	ldr	r0, [pc, #256]	; (80a08e8 <_ZN8sparkbot5beginEv+0x11c>)
 80a07e6:	f000 fbb9 	bl	80a0f5c <_ZN5Servo6attachEtttss>
  leftservo.attach(LEFTSERVO);
 80a07ea:	e88d 0050 	stmia.w	sp, {r4, r6}
 80a07ee:	2101      	movs	r1, #1
 80a07f0:	f44f 7208 	mov.w	r2, #544	; 0x220
 80a07f4:	f44f 6316 	mov.w	r3, #2400	; 0x960
 80a07f8:	483c      	ldr	r0, [pc, #240]	; (80a08ec <_ZN8sparkbot5beginEv+0x120>)
 80a07fa:	f000 fbaf 	bl	80a0f5c <_ZN5Servo6attachEtttss>
  rightservo.attach(RIGHTSERVO); //Here we attach the three servos
 80a07fe:	f44f 7208 	mov.w	r2, #544	; 0x220
 80a0802:	f44f 6316 	mov.w	r3, #2400	; 0x960
 80a0806:	4621      	mov	r1, r4
 80a0808:	e88d 0050 	stmia.w	sp, {r4, r6}
 80a080c:	4838      	ldr	r0, [pc, #224]	; (80a08f0 <_ZN8sparkbot5beginEv+0x124>)
 80a080e:	f000 fba5 	bl	80a0f5c <_ZN5Servo6attachEtttss>

  pinMode(RIGHTBUTTON, INPUT);  //We Enable the inputs.
 80a0812:	4621      	mov	r1, r4
 80a0814:	2007      	movs	r0, #7
 80a0816:	f000 fdc5 	bl	80a13a4 <pinMode>
  pinMode(LEFTBUTTON, INPUT);
 80a081a:	4621      	mov	r1, r4
 80a081c:	2006      	movs	r0, #6
 80a081e:	f000 fdc1 	bl	80a13a4 <pinMode>
  pinMode(PHOTORESISTOR, INPUT);
 80a0822:	4621      	mov	r1, r4
 80a0824:	200a      	movs	r0, #10
 80a0826:	f000 fdbd 	bl	80a13a4 <pinMode>
  pinMode(MICROPHONE, INPUT);
 80a082a:	4621      	mov	r1, r4
 80a082c:	200d      	movs	r0, #13
 80a082e:	f000 fdb9 	bl	80a13a4 <pinMode>

  pinMode(REDLED, OUTPUT); //LEDs
 80a0832:	2003      	movs	r0, #3
 80a0834:	2101      	movs	r1, #1
 80a0836:	f000 fdb5 	bl	80a13a4 <pinMode>
  pinMode(BLUELED, OUTPUT);
 80a083a:	2011      	movs	r0, #17
 80a083c:	2101      	movs	r1, #1
 80a083e:	f000 fdb1 	bl	80a13a4 <pinMode>
  pinMode(GREENLED, OUTPUT);
 80a0842:	2013      	movs	r0, #19
 80a0844:	2101      	movs	r1, #1
 80a0846:	f000 fdad 	bl	80a13a4 <pinMode>

  pinMode(BUZZER, OUTPUT);
 80a084a:	2012      	movs	r0, #18
 80a084c:	2101      	movs	r1, #1
 80a084e:	f000 fda9 	bl	80a13a4 <pinMode>
  rightArmAngle = rightservo.read();
  leftservo.write(90);
  leftArmAngle = leftservo.read();
  */

  Particle.variable("neck", &neckAngle, INT);
 80a0852:	4629      	mov	r1, r5
 80a0854:	4827      	ldr	r0, [pc, #156]	; (80a08f4 <_ZN8sparkbot5beginEv+0x128>)
 80a0856:	f7ff fd75 	bl	80a0344 <_ZN10CloudClass8variableI20CloudVariableTypeIntEEbPKcNT_6varrefERKS4_.isra.4>
  Particle.variable("rightArm", &rightArmAngle, INT);
 80a085a:	1d29      	adds	r1, r5, #4
 80a085c:	4826      	ldr	r0, [pc, #152]	; (80a08f8 <_ZN8sparkbot5beginEv+0x12c>)
 80a085e:	f7ff fd71 	bl	80a0344 <_ZN10CloudClass8variableI20CloudVariableTypeIntEEbPKcNT_6varrefERKS4_.isra.4>
  Particle.variable("leftArm", &leftArmAngle, INT);
 80a0862:	f105 0108 	add.w	r1, r5, #8
 80a0866:	4825      	ldr	r0, [pc, #148]	; (80a08fc <_ZN8sparkbot5beginEv+0x130>)
 80a0868:	f7ff fd6c 	bl	80a0344 <_ZN10CloudClass8variableI20CloudVariableTypeIntEEbPKcNT_6varrefERKS4_.isra.4>
  Particle.variable("brightness", &brightness, INT);
 80a086c:	f105 010c 	add.w	r1, r5, #12
 80a0870:	4823      	ldr	r0, [pc, #140]	; (80a0900 <_ZN8sparkbot5beginEv+0x134>)
 80a0872:	f7ff fd67 	bl	80a0344 <_ZN10CloudClass8variableI20CloudVariableTypeIntEEbPKcNT_6varrefERKS4_.isra.4>
  Particle.variable("noise", &noiseLevel, INT);
 80a0876:	f105 0120 	add.w	r1, r5, #32
 80a087a:	4822      	ldr	r0, [pc, #136]	; (80a0904 <_ZN8sparkbot5beginEv+0x138>)
 80a087c:	f7ff fd62 	bl	80a0344 <_ZN10CloudClass8variableI20CloudVariableTypeIntEEbPKcNT_6varrefERKS4_.isra.4>

  auto moveHandler = std::bind(&sparkbot::moveCloud, this, std::placeholders::_1);
  Particle.function("moveServos", moveHandler);
 80a0880:	4b21      	ldr	r3, [pc, #132]	; (80a0908 <_ZN8sparkbot5beginEv+0x13c>)
 80a0882:	a903      	add	r1, sp, #12
 80a0884:	a80c      	add	r0, sp, #48	; 0x30
 80a0886:	9303      	str	r3, [sp, #12]
 80a0888:	9404      	str	r4, [sp, #16]
 80a088a:	9505      	str	r5, [sp, #20]
 80a088c:	f7ff ff82 	bl	80a0794 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_>
 80a0890:	a90c      	add	r1, sp, #48	; 0x30
 80a0892:	481e      	ldr	r0, [pc, #120]	; (80a090c <_ZN8sparkbot5beginEv+0x140>)
 80a0894:	f7ff fd76 	bl	80a0384 <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0898:	a80c      	add	r0, sp, #48	; 0x30
 80a089a:	f7ff fdaf 	bl	80a03fc <_ZNSt14_Function_baseD1Ev>

  auto moodHandler = std::bind(&sparkbot::moodlightsCloud, this, std::placeholders::_1);
  Particle.function("moodlights", moodHandler);
 80a089e:	4b1c      	ldr	r3, [pc, #112]	; (80a0910 <_ZN8sparkbot5beginEv+0x144>)
 80a08a0:	a906      	add	r1, sp, #24
 80a08a2:	a80c      	add	r0, sp, #48	; 0x30
 80a08a4:	9306      	str	r3, [sp, #24]
 80a08a6:	9407      	str	r4, [sp, #28]
 80a08a8:	9508      	str	r5, [sp, #32]
 80a08aa:	f7ff ff73 	bl	80a0794 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_>
 80a08ae:	a90c      	add	r1, sp, #48	; 0x30
 80a08b0:	4818      	ldr	r0, [pc, #96]	; (80a0914 <_ZN8sparkbot5beginEv+0x148>)
 80a08b2:	f7ff fd67 	bl	80a0384 <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3>
 80a08b6:	a80c      	add	r0, sp, #48	; 0x30
 80a08b8:	f7ff fda0 	bl	80a03fc <_ZNSt14_Function_baseD1Ev>

  auto slaveHandler = std::bind(&sparkbot::slaveToggle, this, std::placeholders::_1);
  Particle.function("enableSlave", slaveHandler);
 80a08bc:	4b16      	ldr	r3, [pc, #88]	; (80a0918 <_ZN8sparkbot5beginEv+0x14c>)
 80a08be:	a909      	add	r1, sp, #36	; 0x24
 80a08c0:	a80c      	add	r0, sp, #48	; 0x30
 80a08c2:	9309      	str	r3, [sp, #36]	; 0x24
 80a08c4:	940a      	str	r4, [sp, #40]	; 0x28
 80a08c6:	950b      	str	r5, [sp, #44]	; 0x2c
 80a08c8:	f7ff ff64 	bl	80a0794 <_ZNSt8functionIFi6StringEEC1ISt5_BindIFSt7_Mem_fnIM8sparkbotFiS0_EEPS6_St12_PlaceholderILi1EEEEvEET_>
 80a08cc:	a90c      	add	r1, sp, #48	; 0x30
 80a08ce:	4813      	ldr	r0, [pc, #76]	; (80a091c <_ZN8sparkbot5beginEv+0x150>)
 80a08d0:	f7ff fd58 	bl	80a0384 <_ZN10CloudClass8functionEPKcSt8functionIFi6StringEEPv.isra.3>
 80a08d4:	a80c      	add	r0, sp, #48	; 0x30
 80a08d6:	f7ff fd91 	bl	80a03fc <_ZNSt14_Function_baseD1Ev>
  Serial.begin(9600);
 80a08da:	4811      	ldr	r0, [pc, #68]	; (80a0920 <_ZN8sparkbot5beginEv+0x154>)
 80a08dc:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a08e0:	f000 fcd0 	bl	80a1284 <_ZN9USBSerial5beginEl>
}
 80a08e4:	b010      	add	sp, #64	; 0x40
 80a08e6:	bd70      	pop	{r4, r5, r6, pc}
 80a08e8:	2000039c 	.word	0x2000039c
 80a08ec:	200003c0 	.word	0x200003c0
 80a08f0:	200003b0 	.word	0x200003b0
 80a08f4:	080a194f 	.word	0x080a194f
 80a08f8:	080a1954 	.word	0x080a1954
 80a08fc:	080a195d 	.word	0x080a195d
 80a0900:	080a1965 	.word	0x080a1965
 80a0904:	080a1970 	.word	0x080a1970
 80a0908:	080a04e5 	.word	0x080a04e5
 80a090c:	080a1976 	.word	0x080a1976
 80a0910:	080a01e9 	.word	0x080a01e9
 80a0914:	080a1981 	.word	0x080a1981
 80a0918:	080a01cd 	.word	0x080a01cd
 80a091c:	080a198c 	.word	0x080a198c
 80a0920:	2000046c 	.word	0x2000046c

080a0924 <_GLOBAL__sub_I_rightservo>:
void sparkbot::refresh()
{
  brightness = lightness();
  noiseLevel = getNoiseLevel();

}
 80a0924:	b508      	push	{r3, lr}
 80a0926:	f000 f825 	bl	80a0974 <HAL_Pin_Map>
 80a092a:	4b06      	ldr	r3, [pc, #24]	; (80a0944 <_GLOBAL__sub_I_rightservo+0x20>)
 80a092c:	6018      	str	r0, [r3, #0]
#include "sparkbot-default.h"
#include "application.h"

Servo rightservo;
 80a092e:	4806      	ldr	r0, [pc, #24]	; (80a0948 <_GLOBAL__sub_I_rightservo+0x24>)
 80a0930:	f000 faff 	bl	80a0f32 <_ZN5ServoC1Ev>
Servo leftservo;
 80a0934:	4805      	ldr	r0, [pc, #20]	; (80a094c <_GLOBAL__sub_I_rightservo+0x28>)
 80a0936:	f000 fafc 	bl	80a0f32 <_ZN5ServoC1Ev>
void sparkbot::refresh()
{
  brightness = lightness();
  noiseLevel = getNoiseLevel();

}
 80a093a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#include "sparkbot-default.h"
#include "application.h"

Servo rightservo;
Servo leftservo;
Servo neckservo;
 80a093e:	4804      	ldr	r0, [pc, #16]	; (80a0950 <_GLOBAL__sub_I_rightservo+0x2c>)
 80a0940:	f000 baf7 	b.w	80a0f32 <_ZN5ServoC1Ev>
 80a0944:	200003ac 	.word	0x200003ac
 80a0948:	200003b0 	.word	0x200003b0
 80a094c:	200003c0 	.word	0x200003c0
 80a0950:	2000039c 	.word	0x2000039c

080a0954 <HAL_EEPROM_Init>:
DYNALIB_FN(hal,HAL_RTC_Configuration)
DYNALIB_FN(hal,HAL_RTC_Get_UnixTime)
DYNALIB_FN(hal,HAL_RTC_Set_UnixTime)
DYNALIB_FN(hal,HAL_RTC_Set_UnixAlarm)

DYNALIB_FN(hal,HAL_EEPROM_Init)
 80a0954:	b508      	push	{r3, lr}
 80a0956:	4b02      	ldr	r3, [pc, #8]	; (80a0960 <HAL_EEPROM_Init+0xc>)
 80a0958:	681b      	ldr	r3, [r3, #0]
 80a095a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a095c:	9301      	str	r3, [sp, #4]
 80a095e:	bd08      	pop	{r3, pc}
 80a0960:	0806019c 	.word	0x0806019c

080a0964 <HAL_EEPROM_Length>:
DYNALIB_FN(hal,HAL_EEPROM_Read)
DYNALIB_FN(hal,HAL_EEPROM_Write)
DYNALIB_FN(hal,HAL_EEPROM_Length)
 80a0964:	b508      	push	{r3, lr}
 80a0966:	4b02      	ldr	r3, [pc, #8]	; (80a0970 <HAL_EEPROM_Length+0xc>)
 80a0968:	681b      	ldr	r3, [r3, #0]
 80a096a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a096c:	9301      	str	r3, [sp, #4]
 80a096e:	bd08      	pop	{r3, pc}
 80a0970:	0806019c 	.word	0x0806019c

080a0974 <HAL_Pin_Map>:
// Function signatures shouldn't be changed other than changing pointer types.
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)
DYNALIB_FN(hal_gpio,HAL_Pin_Map)
 80a0974:	b508      	push	{r3, lr}
 80a0976:	4b02      	ldr	r3, [pc, #8]	; (80a0980 <HAL_Pin_Map+0xc>)
 80a0978:	681b      	ldr	r3, [r3, #0]
 80a097a:	681b      	ldr	r3, [r3, #0]
 80a097c:	9301      	str	r3, [sp, #4]
 80a097e:	bd08      	pop	{r3, pc}
 80a0980:	080601b0 	.word	0x080601b0

080a0984 <HAL_Validate_Pin_Function>:
DYNALIB_FN(hal_gpio,HAL_Validate_Pin_Function)
 80a0984:	b508      	push	{r3, lr}
 80a0986:	4b02      	ldr	r3, [pc, #8]	; (80a0990 <HAL_Validate_Pin_Function+0xc>)
 80a0988:	681b      	ldr	r3, [r3, #0]
 80a098a:	685b      	ldr	r3, [r3, #4]
 80a098c:	9301      	str	r3, [sp, #4]
 80a098e:	bd08      	pop	{r3, pc}
 80a0990:	080601b0 	.word	0x080601b0

080a0994 <HAL_Pin_Mode>:
DYNALIB_FN(hal_gpio,HAL_Pin_Mode)
 80a0994:	b508      	push	{r3, lr}
 80a0996:	4b02      	ldr	r3, [pc, #8]	; (80a09a0 <HAL_Pin_Mode+0xc>)
 80a0998:	681b      	ldr	r3, [r3, #0]
 80a099a:	689b      	ldr	r3, [r3, #8]
 80a099c:	9301      	str	r3, [sp, #4]
 80a099e:	bd08      	pop	{r3, pc}
 80a09a0:	080601b0 	.word	0x080601b0

080a09a4 <HAL_Get_Pin_Mode>:
DYNALIB_FN(hal_gpio,HAL_Get_Pin_Mode)
 80a09a4:	b508      	push	{r3, lr}
 80a09a6:	4b02      	ldr	r3, [pc, #8]	; (80a09b0 <HAL_Get_Pin_Mode+0xc>)
 80a09a8:	681b      	ldr	r3, [r3, #0]
 80a09aa:	68db      	ldr	r3, [r3, #12]
 80a09ac:	9301      	str	r3, [sp, #4]
 80a09ae:	bd08      	pop	{r3, pc}
 80a09b0:	080601b0 	.word	0x080601b0

080a09b4 <HAL_GPIO_Write>:
DYNALIB_FN(hal_gpio,HAL_GPIO_Write)
 80a09b4:	b508      	push	{r3, lr}
 80a09b6:	4b02      	ldr	r3, [pc, #8]	; (80a09c0 <HAL_GPIO_Write+0xc>)
 80a09b8:	681b      	ldr	r3, [r3, #0]
 80a09ba:	691b      	ldr	r3, [r3, #16]
 80a09bc:	9301      	str	r3, [sp, #4]
 80a09be:	bd08      	pop	{r3, pc}
 80a09c0:	080601b0 	.word	0x080601b0

080a09c4 <HAL_GPIO_Read>:
DYNALIB_FN(hal_gpio,HAL_GPIO_Read)
 80a09c4:	b508      	push	{r3, lr}
 80a09c6:	4b02      	ldr	r3, [pc, #8]	; (80a09d0 <HAL_GPIO_Read+0xc>)
 80a09c8:	681b      	ldr	r3, [r3, #0]
 80a09ca:	695b      	ldr	r3, [r3, #20]
 80a09cc:	9301      	str	r3, [sp, #4]
 80a09ce:	bd08      	pop	{r3, pc}
 80a09d0:	080601b0 	.word	0x080601b0

080a09d4 <HAL_Interrupts_Enable_All>:
DYNALIB_FN(hal_gpio,HAL_Interrupts_Attach)
DYNALIB_FN(hal_gpio,HAL_Interrupts_Detach)
DYNALIB_FN(hal_gpio,HAL_Interrupts_Enable_All)
 80a09d4:	b508      	push	{r3, lr}
 80a09d6:	4b02      	ldr	r3, [pc, #8]	; (80a09e0 <HAL_Interrupts_Enable_All+0xc>)
 80a09d8:	681b      	ldr	r3, [r3, #0]
 80a09da:	6a1b      	ldr	r3, [r3, #32]
 80a09dc:	9301      	str	r3, [sp, #4]
 80a09de:	bd08      	pop	{r3, pc}
 80a09e0:	080601b0 	.word	0x080601b0

080a09e4 <HAL_DAC_Write>:
DYNALIB_FN(hal_gpio,HAL_Interrupts_Disable_All)

DYNALIB_FN(hal_gpio,HAL_DAC_Write)
 80a09e4:	b508      	push	{r3, lr}
 80a09e6:	4b02      	ldr	r3, [pc, #8]	; (80a09f0 <HAL_DAC_Write+0xc>)
 80a09e8:	681b      	ldr	r3, [r3, #0]
 80a09ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a09ec:	9301      	str	r3, [sp, #4]
 80a09ee:	bd08      	pop	{r3, pc}
 80a09f0:	080601b0 	.word	0x080601b0

080a09f4 <HAL_ADC_Read>:
DYNALIB_FN(hal_gpio,HAL_ADC_Set_Sample_Time)
DYNALIB_FN(hal_gpio,HAL_ADC_Read)
 80a09f4:	b508      	push	{r3, lr}
 80a09f6:	4b02      	ldr	r3, [pc, #8]	; (80a0a00 <HAL_ADC_Read+0xc>)
 80a09f8:	681b      	ldr	r3, [r3, #0]
 80a09fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a09fc:	9301      	str	r3, [sp, #4]
 80a09fe:	bd08      	pop	{r3, pc}
 80a0a00:	080601b0 	.word	0x080601b0

080a0a04 <HAL_PWM_Write>:

DYNALIB_FN(hal_gpio,HAL_PWM_Write)
 80a0a04:	b508      	push	{r3, lr}
 80a0a06:	4b02      	ldr	r3, [pc, #8]	; (80a0a10 <HAL_PWM_Write+0xc>)
 80a0a08:	681b      	ldr	r3, [r3, #0]
 80a0a0a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0a0c:	9301      	str	r3, [sp, #4]
 80a0a0e:	bd08      	pop	{r3, pc}
 80a0a10:	080601b0 	.word	0x080601b0

080a0a14 <HAL_I2C_Write_Data>:
DYNALIB_FN(hal_i2c,HAL_I2C_Begin)
DYNALIB_FN(hal_i2c,HAL_I2C_End)
DYNALIB_FN(hal_i2c,HAL_I2C_Request_Data)
DYNALIB_FN(hal_i2c,HAL_I2C_Begin_Transmission)
DYNALIB_FN(hal_i2c,HAL_I2C_End_Transmission)
DYNALIB_FN(hal_i2c,HAL_I2C_Write_Data)
 80a0a14:	b508      	push	{r3, lr}
 80a0a16:	4b02      	ldr	r3, [pc, #8]	; (80a0a20 <HAL_I2C_Write_Data+0xc>)
 80a0a18:	681b      	ldr	r3, [r3, #0]
 80a0a1a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a0a1c:	9301      	str	r3, [sp, #4]
 80a0a1e:	bd08      	pop	{r3, pc}
 80a0a20:	080601ac 	.word	0x080601ac

080a0a24 <HAL_I2C_Available_Data>:
DYNALIB_FN(hal_i2c,HAL_I2C_Available_Data)
 80a0a24:	b508      	push	{r3, lr}
 80a0a26:	4b02      	ldr	r3, [pc, #8]	; (80a0a30 <HAL_I2C_Available_Data+0xc>)
 80a0a28:	681b      	ldr	r3, [r3, #0]
 80a0a2a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0a2c:	9301      	str	r3, [sp, #4]
 80a0a2e:	bd08      	pop	{r3, pc}
 80a0a30:	080601ac 	.word	0x080601ac

080a0a34 <HAL_I2C_Read_Data>:
DYNALIB_FN(hal_i2c,HAL_I2C_Read_Data)
 80a0a34:	b508      	push	{r3, lr}
 80a0a36:	4b02      	ldr	r3, [pc, #8]	; (80a0a40 <HAL_I2C_Read_Data+0xc>)
 80a0a38:	681b      	ldr	r3, [r3, #0]
 80a0a3a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a0a3c:	9301      	str	r3, [sp, #4]
 80a0a3e:	bd08      	pop	{r3, pc}
 80a0a40:	080601ac 	.word	0x080601ac

080a0a44 <HAL_I2C_Peek_Data>:
DYNALIB_FN(hal_i2c,HAL_I2C_Peek_Data)
 80a0a44:	b508      	push	{r3, lr}
 80a0a46:	4b02      	ldr	r3, [pc, #8]	; (80a0a50 <HAL_I2C_Peek_Data+0xc>)
 80a0a48:	681b      	ldr	r3, [r3, #0]
 80a0a4a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0a4c:	9301      	str	r3, [sp, #4]
 80a0a4e:	bd08      	pop	{r3, pc}
 80a0a50:	080601ac 	.word	0x080601ac

080a0a54 <HAL_I2C_Flush_Data>:
DYNALIB_FN(hal_i2c,HAL_I2C_Flush_Data)
 80a0a54:	b508      	push	{r3, lr}
 80a0a56:	4b02      	ldr	r3, [pc, #8]	; (80a0a60 <HAL_I2C_Flush_Data+0xc>)
 80a0a58:	681b      	ldr	r3, [r3, #0]
 80a0a5a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a0a5c:	9301      	str	r3, [sp, #4]
 80a0a5e:	bd08      	pop	{r3, pc}
 80a0a60:	080601ac 	.word	0x080601ac

080a0a64 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(hal_i2c,HAL_I2C_Is_Enabled)
 80a0a64:	b508      	push	{r3, lr}
 80a0a66:	4b02      	ldr	r3, [pc, #8]	; (80a0a70 <HAL_I2C_Is_Enabled+0xc>)
 80a0a68:	681b      	ldr	r3, [r3, #0]
 80a0a6a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a0a6c:	9301      	str	r3, [sp, #4]
 80a0a6e:	bd08      	pop	{r3, pc}
 80a0a70:	080601ac 	.word	0x080601ac

080a0a74 <HAL_I2C_Init>:
DYNALIB_FN(hal_i2c,HAL_I2C_Set_Callback_On_Receive)
DYNALIB_FN(hal_i2c,HAL_I2C_Set_Callback_On_Request)
DYNALIB_FN(hal_i2c,HAL_I2C_Init)
 80a0a74:	b508      	push	{r3, lr}
 80a0a76:	4b03      	ldr	r3, [pc, #12]	; (80a0a84 <HAL_I2C_Init+0x10>)
 80a0a78:	681b      	ldr	r3, [r3, #0]
 80a0a7a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a0a7e:	9301      	str	r3, [sp, #4]
 80a0a80:	bd08      	pop	{r3, pc}
 80a0a82:	0000      	.short	0x0000
 80a0a84:	080601ac 	.word	0x080601ac

080a0a88 <HAL_Servo_Attach>:
DYNALIB_FN(hal_peripherals,HAL_Tone_Start)
DYNALIB_FN(hal_peripherals,HAL_Tone_Stop)
DYNALIB_FN(hal_peripherals,HAL_Tone_Get_Frequency)
DYNALIB_FN(hal_peripherals,HAL_Tone_Is_Stopped)

DYNALIB_FN(hal_peripherals,HAL_Servo_Attach)
 80a0a88:	b508      	push	{r3, lr}
 80a0a8a:	4b02      	ldr	r3, [pc, #8]	; (80a0a94 <HAL_Servo_Attach+0xc>)
 80a0a8c:	681b      	ldr	r3, [r3, #0]
 80a0a8e:	691b      	ldr	r3, [r3, #16]
 80a0a90:	9301      	str	r3, [sp, #4]
 80a0a92:	bd08      	pop	{r3, pc}
 80a0a94:	080601a8 	.word	0x080601a8

080a0a98 <HAL_Servo_Detach>:
DYNALIB_FN(hal_peripherals,HAL_Servo_Detach)
 80a0a98:	b508      	push	{r3, lr}
 80a0a9a:	4b02      	ldr	r3, [pc, #8]	; (80a0aa4 <HAL_Servo_Detach+0xc>)
 80a0a9c:	681b      	ldr	r3, [r3, #0]
 80a0a9e:	695b      	ldr	r3, [r3, #20]
 80a0aa0:	9301      	str	r3, [sp, #4]
 80a0aa2:	bd08      	pop	{r3, pc}
 80a0aa4:	080601a8 	.word	0x080601a8

080a0aa8 <HAL_Servo_Write_Pulse_Width>:
DYNALIB_FN(hal_peripherals,HAL_Servo_Write_Pulse_Width)
 80a0aa8:	b508      	push	{r3, lr}
 80a0aaa:	4b02      	ldr	r3, [pc, #8]	; (80a0ab4 <HAL_Servo_Write_Pulse_Width+0xc>)
 80a0aac:	681b      	ldr	r3, [r3, #0]
 80a0aae:	699b      	ldr	r3, [r3, #24]
 80a0ab0:	9301      	str	r3, [sp, #4]
 80a0ab2:	bd08      	pop	{r3, pc}
 80a0ab4:	080601a8 	.word	0x080601a8

080a0ab8 <HAL_SPI_Init>:
DYNALIB_FN(hal_spi,HAL_SPI_Set_Bit_Order)
DYNALIB_FN(hal_spi,HAL_SPI_Set_Data_Mode)
DYNALIB_FN(hal_spi,HAL_SPI_Set_Clock_Divider)
DYNALIB_FN(hal_spi,HAL_SPI_Send_Receive_Data)
DYNALIB_FN(hal_spi,HAL_SPI_Is_Enabled_Old)
DYNALIB_FN(hal_spi,HAL_SPI_Init)
 80a0ab8:	b508      	push	{r3, lr}
 80a0aba:	4b02      	ldr	r3, [pc, #8]	; (80a0ac4 <HAL_SPI_Init+0xc>)
 80a0abc:	681b      	ldr	r3, [r3, #0]
 80a0abe:	69db      	ldr	r3, [r3, #28]
 80a0ac0:	9301      	str	r3, [sp, #4]
 80a0ac2:	bd08      	pop	{r3, pc}
 80a0ac4:	080601b4 	.word	0x080601b4

080a0ac8 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(hal_spi,HAL_SPI_Is_Enabled)
 80a0ac8:	b508      	push	{r3, lr}
 80a0aca:	4b02      	ldr	r3, [pc, #8]	; (80a0ad4 <HAL_SPI_Is_Enabled+0xc>)
 80a0acc:	681b      	ldr	r3, [r3, #0]
 80a0ace:	6a1b      	ldr	r3, [r3, #32]
 80a0ad0:	9301      	str	r3, [sp, #4]
 80a0ad2:	bd08      	pop	{r3, pc}
 80a0ad4:	080601b4 	.word	0x080601b4

080a0ad8 <USB_USART_Init>:
// GNINRAW

DYNALIB_BEGIN(hal_usart)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(hal_usart,USB_USART_Init)
 80a0ad8:	b508      	push	{r3, lr}
 80a0ada:	4b02      	ldr	r3, [pc, #8]	; (80a0ae4 <USB_USART_Init+0xc>)
 80a0adc:	681b      	ldr	r3, [r3, #0]
 80a0ade:	681b      	ldr	r3, [r3, #0]
 80a0ae0:	9301      	str	r3, [sp, #4]
 80a0ae2:	bd08      	pop	{r3, pc}
 80a0ae4:	080601c4 	.word	0x080601c4

080a0ae8 <USB_USART_Available_Data>:
DYNALIB_FN(hal_usart,USB_USART_Available_Data)
 80a0ae8:	b508      	push	{r3, lr}
 80a0aea:	4b02      	ldr	r3, [pc, #8]	; (80a0af4 <USB_USART_Available_Data+0xc>)
 80a0aec:	681b      	ldr	r3, [r3, #0]
 80a0aee:	685b      	ldr	r3, [r3, #4]
 80a0af0:	9301      	str	r3, [sp, #4]
 80a0af2:	bd08      	pop	{r3, pc}
 80a0af4:	080601c4 	.word	0x080601c4

080a0af8 <USB_USART_Receive_Data>:
DYNALIB_FN(hal_usart,USB_USART_Receive_Data)
 80a0af8:	b508      	push	{r3, lr}
 80a0afa:	4b02      	ldr	r3, [pc, #8]	; (80a0b04 <USB_USART_Receive_Data+0xc>)
 80a0afc:	681b      	ldr	r3, [r3, #0]
 80a0afe:	689b      	ldr	r3, [r3, #8]
 80a0b00:	9301      	str	r3, [sp, #4]
 80a0b02:	bd08      	pop	{r3, pc}
 80a0b04:	080601c4 	.word	0x080601c4

080a0b08 <USB_USART_Send_Data>:
DYNALIB_FN(hal_usart,USB_USART_Send_Data)
 80a0b08:	b508      	push	{r3, lr}
 80a0b0a:	4b02      	ldr	r3, [pc, #8]	; (80a0b14 <USB_USART_Send_Data+0xc>)
 80a0b0c:	681b      	ldr	r3, [r3, #0]
 80a0b0e:	68db      	ldr	r3, [r3, #12]
 80a0b10:	9301      	str	r3, [sp, #4]
 80a0b12:	bd08      	pop	{r3, pc}
 80a0b14:	080601c4 	.word	0x080601c4

080a0b18 <HAL_USART_Init>:
DYNALIB_FN(hal_usart,USB_USART_Baud_Rate)
DYNALIB_FN(hal_usart,USB_USART_LineCoding_BitRate_Handler)
#endif

DYNALIB_FN(hal_usart,HAL_USART_Init)
 80a0b18:	b508      	push	{r3, lr}
 80a0b1a:	4b02      	ldr	r3, [pc, #8]	; (80a0b24 <HAL_USART_Init+0xc>)
 80a0b1c:	681b      	ldr	r3, [r3, #0]
 80a0b1e:	699b      	ldr	r3, [r3, #24]
 80a0b20:	9301      	str	r3, [sp, #4]
 80a0b22:	bd08      	pop	{r3, pc}
 80a0b24:	080601c4 	.word	0x080601c4

080a0b28 <HAL_USART_Write_Data>:
DYNALIB_FN(hal_usart,HAL_USART_Begin)
DYNALIB_FN(hal_usart,HAL_USART_End)
DYNALIB_FN(hal_usart,HAL_USART_Write_Data)
 80a0b28:	b508      	push	{r3, lr}
 80a0b2a:	4b02      	ldr	r3, [pc, #8]	; (80a0b34 <HAL_USART_Write_Data+0xc>)
 80a0b2c:	681b      	ldr	r3, [r3, #0]
 80a0b2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0b30:	9301      	str	r3, [sp, #4]
 80a0b32:	bd08      	pop	{r3, pc}
 80a0b34:	080601c4 	.word	0x080601c4

080a0b38 <HAL_USART_Available_Data>:
DYNALIB_FN(hal_usart,HAL_USART_Available_Data)
 80a0b38:	b508      	push	{r3, lr}
 80a0b3a:	4b02      	ldr	r3, [pc, #8]	; (80a0b44 <HAL_USART_Available_Data+0xc>)
 80a0b3c:	681b      	ldr	r3, [r3, #0]
 80a0b3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0b40:	9301      	str	r3, [sp, #4]
 80a0b42:	bd08      	pop	{r3, pc}
 80a0b44:	080601c4 	.word	0x080601c4

080a0b48 <HAL_USART_Read_Data>:
DYNALIB_FN(hal_usart,HAL_USART_Read_Data)
 80a0b48:	b508      	push	{r3, lr}
 80a0b4a:	4b02      	ldr	r3, [pc, #8]	; (80a0b54 <HAL_USART_Read_Data+0xc>)
 80a0b4c:	681b      	ldr	r3, [r3, #0]
 80a0b4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0b50:	9301      	str	r3, [sp, #4]
 80a0b52:	bd08      	pop	{r3, pc}
 80a0b54:	080601c4 	.word	0x080601c4

080a0b58 <HAL_USART_Peek_Data>:
DYNALIB_FN(hal_usart,HAL_USART_Peek_Data)
 80a0b58:	b508      	push	{r3, lr}
 80a0b5a:	4b02      	ldr	r3, [pc, #8]	; (80a0b64 <HAL_USART_Peek_Data+0xc>)
 80a0b5c:	681b      	ldr	r3, [r3, #0]
 80a0b5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0b60:	9301      	str	r3, [sp, #4]
 80a0b62:	bd08      	pop	{r3, pc}
 80a0b64:	080601c4 	.word	0x080601c4

080a0b68 <HAL_USART_Flush_Data>:
DYNALIB_FN(hal_usart,HAL_USART_Flush_Data)
 80a0b68:	b508      	push	{r3, lr}
 80a0b6a:	4b02      	ldr	r3, [pc, #8]	; (80a0b74 <HAL_USART_Flush_Data+0xc>)
 80a0b6c:	681b      	ldr	r3, [r3, #0]
 80a0b6e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0b70:	9301      	str	r3, [sp, #4]
 80a0b72:	bd08      	pop	{r3, pc}
 80a0b74:	080601c4 	.word	0x080601c4

080a0b78 <HAL_USART_Is_Enabled>:
DYNALIB_FN(hal_usart,HAL_USART_Is_Enabled)
 80a0b78:	b508      	push	{r3, lr}
 80a0b7a:	4b02      	ldr	r3, [pc, #8]	; (80a0b84 <HAL_USART_Is_Enabled+0xc>)
 80a0b7c:	681b      	ldr	r3, [r3, #0]
 80a0b7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a0b80:	9301      	str	r3, [sp, #4]
 80a0b82:	bd08      	pop	{r3, pc}
 80a0b84:	080601c4 	.word	0x080601c4

080a0b88 <set_system_mode>:
#include "system_event.h"
#endif

DYNALIB_BEGIN(system)
DYNALIB_FN(system, system_mode)
DYNALIB_FN(system, set_system_mode)
 80a0b88:	b508      	push	{r3, lr}
 80a0b8a:	4b02      	ldr	r3, [pc, #8]	; (80a0b94 <set_system_mode+0xc>)
 80a0b8c:	681b      	ldr	r3, [r3, #0]
 80a0b8e:	685b      	ldr	r3, [r3, #4]
 80a0b90:	9301      	str	r3, [sp, #4]
 80a0b92:	bd08      	pop	{r3, pc}
 80a0b94:	080601a4 	.word	0x080601a4

080a0b98 <system_delay_ms>:

DYNALIB_FN(system, set_ymodem_serial_flash_update_handler)
DYNALIB_FN(system, system_firmwareUpdate)
DYNALIB_FN(system, system_fileTransfer)

DYNALIB_FN(system, system_delay_ms)
 80a0b98:	b508      	push	{r3, lr}
 80a0b9a:	4b02      	ldr	r3, [pc, #8]	; (80a0ba4 <system_delay_ms+0xc>)
 80a0b9c:	681b      	ldr	r3, [r3, #0]
 80a0b9e:	695b      	ldr	r3, [r3, #20]
 80a0ba0:	9301      	str	r3, [sp, #4]
 80a0ba2:	bd08      	pop	{r3, pc}
 80a0ba4:	080601a4 	.word	0x080601a4

080a0ba8 <system_thread_set_state>:
DYNALIB_FN(system, system_sleep)
DYNALIB_FN(system, system_sleep_pin)
DYNALIB_FN(system, system_subscribe_event)
DYNALIB_FN(system, system_unsubscribe_event)
DYNALIB_FN(system, system_button_pushed_duration)
DYNALIB_FN(system, system_thread_set_state)
 80a0ba8:	b508      	push	{r3, lr}
 80a0baa:	4b02      	ldr	r3, [pc, #8]	; (80a0bb4 <system_thread_set_state+0xc>)
 80a0bac:	681b      	ldr	r3, [r3, #0]
 80a0bae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0bb0:	9301      	str	r3, [sp, #4]
 80a0bb2:	bd08      	pop	{r3, pc}
 80a0bb4:	080601a4 	.word	0x080601a4

080a0bb8 <spark_variable>:
#include "system_cloud.h"
#endif


DYNALIB_BEGIN(system_cloud)
DYNALIB_FN(system_cloud, spark_variable)
 80a0bb8:	b508      	push	{r3, lr}
 80a0bba:	4b02      	ldr	r3, [pc, #8]	; (80a0bc4 <spark_variable+0xc>)
 80a0bbc:	681b      	ldr	r3, [r3, #0]
 80a0bbe:	681b      	ldr	r3, [r3, #0]
 80a0bc0:	9301      	str	r3, [sp, #4]
 80a0bc2:	bd08      	pop	{r3, pc}
 80a0bc4:	080601cc 	.word	0x080601cc

080a0bc8 <spark_function>:
DYNALIB_FN(system_cloud, spark_function)
 80a0bc8:	b508      	push	{r3, lr}
 80a0bca:	4b02      	ldr	r3, [pc, #8]	; (80a0bd4 <spark_function+0xc>)
 80a0bcc:	681b      	ldr	r3, [r3, #0]
 80a0bce:	685b      	ldr	r3, [r3, #4]
 80a0bd0:	9301      	str	r3, [sp, #4]
 80a0bd2:	bd08      	pop	{r3, pc}
 80a0bd4:	080601cc 	.word	0x080601cc

080a0bd8 <spark_send_event>:
DYNALIB_FN(system_cloud, spark_connect)
DYNALIB_FN(system_cloud, spark_disconnect)
DYNALIB_FN(system_cloud, spark_connected)
DYNALIB_FN(system_cloud, system_cloud_protocol_instance)
DYNALIB_FN(system_cloud, spark_deviceID)
DYNALIB_FN(system_cloud, spark_send_event)
 80a0bd8:	b508      	push	{r3, lr}
 80a0bda:	4b02      	ldr	r3, [pc, #8]	; (80a0be4 <spark_send_event+0xc>)
 80a0bdc:	681b      	ldr	r3, [r3, #0]
 80a0bde:	6a1b      	ldr	r3, [r3, #32]
 80a0be0:	9301      	str	r3, [sp, #4]
 80a0be2:	bd08      	pop	{r3, pc}
 80a0be4:	080601cc 	.word	0x080601cc

080a0be8 <spark_subscribe>:
DYNALIB_FN(system_cloud, spark_subscribe)
 80a0be8:	b508      	push	{r3, lr}
 80a0bea:	4b02      	ldr	r3, [pc, #8]	; (80a0bf4 <spark_subscribe+0xc>)
 80a0bec:	681b      	ldr	r3, [r3, #0]
 80a0bee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0bf0:	9301      	str	r3, [sp, #4]
 80a0bf2:	bd08      	pop	{r3, pc}
 80a0bf4:	080601cc 	.word	0x080601cc

080a0bf8 <network_ready>:
DYNALIB_BEGIN(system_net)
DYNALIB_FN(system_net, network_config)
DYNALIB_FN(system_net, network_connect)
DYNALIB_FN(system_net, network_connecting)
DYNALIB_FN(system_net, network_disconnect)
DYNALIB_FN(system_net, network_ready)
 80a0bf8:	b508      	push	{r3, lr}
 80a0bfa:	4b02      	ldr	r3, [pc, #8]	; (80a0c04 <network_ready+0xc>)
 80a0bfc:	681b      	ldr	r3, [r3, #0]
 80a0bfe:	691b      	ldr	r3, [r3, #16]
 80a0c00:	9301      	str	r3, [sp, #4]
 80a0c02:	bd08      	pop	{r3, pc}
 80a0c04:	080601c8 	.word	0x080601c8

080a0c08 <malloc>:
#pragma once

#include "dynalib.h"

DYNALIB_BEGIN(rt)
DYNALIB_FN(rt, malloc)
 80a0c08:	b508      	push	{r3, lr}
 80a0c0a:	4b02      	ldr	r3, [pc, #8]	; (80a0c14 <malloc+0xc>)
 80a0c0c:	681b      	ldr	r3, [r3, #0]
 80a0c0e:	681b      	ldr	r3, [r3, #0]
 80a0c10:	9301      	str	r3, [sp, #4]
 80a0c12:	bd08      	pop	{r3, pc}
 80a0c14:	080601a0 	.word	0x080601a0

080a0c18 <free>:
DYNALIB_FN(rt, free)
 80a0c18:	b508      	push	{r3, lr}
 80a0c1a:	4b02      	ldr	r3, [pc, #8]	; (80a0c24 <free+0xc>)
 80a0c1c:	681b      	ldr	r3, [r3, #0]
 80a0c1e:	685b      	ldr	r3, [r3, #4]
 80a0c20:	9301      	str	r3, [sp, #4]
 80a0c22:	bd08      	pop	{r3, pc}
 80a0c24:	080601a0 	.word	0x080601a0

080a0c28 <realloc>:
DYNALIB_FN(rt, realloc)
 80a0c28:	b508      	push	{r3, lr}
 80a0c2a:	4b02      	ldr	r3, [pc, #8]	; (80a0c34 <realloc+0xc>)
 80a0c2c:	681b      	ldr	r3, [r3, #0]
 80a0c2e:	689b      	ldr	r3, [r3, #8]
 80a0c30:	9301      	str	r3, [sp, #4]
 80a0c32:	bd08      	pop	{r3, pc}
 80a0c34:	080601a0 	.word	0x080601a0

080a0c38 <abort>:
DYNALIB_FN(rt, siscanf)
DYNALIB_FN(rt, snprintf)
DYNALIB_FN(rt, sniprintf)
DYNALIB_FN(rt, vsnprintf)
DYNALIB_FN(rt, vsniprintf)
DYNALIB_FN(rt, abort)
 80a0c38:	b508      	push	{r3, lr}
 80a0c3a:	4b02      	ldr	r3, [pc, #8]	; (80a0c44 <abort+0xc>)
 80a0c3c:	681b      	ldr	r3, [r3, #0]
 80a0c3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0c40:	9301      	str	r3, [sp, #4]
 80a0c42:	bd08      	pop	{r3, pc}
 80a0c44:	080601a0 	.word	0x080601a0

080a0c48 <map>:
{
  HAL_ADC_Set_Sample_Time(ADC_SampleTime);
}

long map(long value, long fromStart, long fromEnd, long toStart, long toEnd)
{
 80a0c48:	b510      	push	{r4, lr}
  return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
 80a0c4a:	9c02      	ldr	r4, [sp, #8]
 80a0c4c:	1a40      	subs	r0, r0, r1
 80a0c4e:	1ae4      	subs	r4, r4, r3
 80a0c50:	4360      	muls	r0, r4
 80a0c52:	1a52      	subs	r2, r2, r1
 80a0c54:	fb90 f0f2 	sdiv	r0, r0, r2
}
 80a0c58:	4418      	add	r0, r3
 80a0c5a:	bd10      	pop	{r4, pc}

080a0c5c <delay>:

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0c5c:	2100      	movs	r1, #0
 80a0c5e:	f7ff bf9b 	b.w	80a0b98 <system_delay_ms>

080a0c62 <_ZN10CloudClass22call_std_user_functionEPvPKcS0_>:
    String p(param);
    return (*fn)(p);
}

int CloudClass::call_std_user_function(void* data, const char* param, void* reserved)
{
 80a0c62:	b530      	push	{r4, r5, lr}
 80a0c64:	4604      	mov	r4, r0
 80a0c66:	b089      	sub	sp, #36	; 0x24
    user_std_function_int_str_t* fn = (user_std_function_int_str_t*)(data);
    return (*fn)(String(param));
 80a0c68:	4668      	mov	r0, sp
 80a0c6a:	f000 fa0c 	bl	80a1086 <_ZN6StringC1EPKc>
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a0c6e:	68a3      	ldr	r3, [r4, #8]
 80a0c70:	b90b      	cbnz	r3, 80a0c76 <_ZN10CloudClass22call_std_user_functionEPvPKcS0_+0x14>
	__throw_bad_function_call();
 80a0c72:	f000 fccd 	bl	80a1610 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a0c76:	4669      	mov	r1, sp
 80a0c78:	a804      	add	r0, sp, #16
 80a0c7a:	68e5      	ldr	r5, [r4, #12]
 80a0c7c:	f000 f9b1 	bl	80a0fe2 <_ZN6StringC1EOS_>
 80a0c80:	a904      	add	r1, sp, #16
 80a0c82:	4620      	mov	r0, r4
 80a0c84:	47a8      	blx	r5
 80a0c86:	4604      	mov	r4, r0
 80a0c88:	a804      	add	r0, sp, #16
 80a0c8a:	f000 f9ba 	bl	80a1002 <_ZN6StringD1Ev>
 80a0c8e:	4668      	mov	r0, sp
 80a0c90:	f000 f9b7 	bl	80a1002 <_ZN6StringD1Ev>
}
 80a0c94:	4620      	mov	r0, r4
 80a0c96:	b009      	add	sp, #36	; 0x24
 80a0c98:	bd30      	pop	{r4, r5, pc}

080a0c9a <_ZN10CloudClass17register_functionEPFiPvPKcS0_ES0_S2_>:
    wiring_event_handler_t* fn = (wiring_event_handler_t*)(handler_data);
    (*fn)(event_name, data);
}

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
 80a0c9a:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a0c9c:	4607      	mov	r7, r0
 80a0c9e:	460e      	mov	r6, r1
 80a0ca0:	4615      	mov	r5, r2
 80a0ca2:	b085      	sub	sp, #20
    const char *funcKey;
    cloud_function_t fn;
    void* data;

     cloud_function_descriptor() {
         memset(this, 0, sizeof(*this));
 80a0ca4:	2410      	movs	r4, #16
 80a0ca6:	4622      	mov	r2, r4
 80a0ca8:	4668      	mov	r0, sp
 80a0caa:	2100      	movs	r1, #0
 80a0cac:	f000 fd47 	bl	80a173e <memset>
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
 80a0cb0:	4622      	mov	r2, r4
 80a0cb2:	4668      	mov	r0, sp
 80a0cb4:	2100      	movs	r1, #0
 80a0cb6:	f000 fd42 	bl	80a173e <memset>
    desc.size = sizeof(desc);
    desc.fn = fn;
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a0cba:	2000      	movs	r0, #0
 80a0cbc:	4669      	mov	r1, sp
 80a0cbe:	4602      	mov	r2, r0

bool CloudClass::register_function(cloud_function_t fn, void* data, const char* funcKey)
{
    cloud_function_descriptor desc;
    memset(&desc, 0, sizeof(desc));
    desc.size = sizeof(desc);
 80a0cc0:	f8ad 4000 	strh.w	r4, [sp]
    desc.fn = fn;
 80a0cc4:	9702      	str	r7, [sp, #8]
    desc.data = (void*)data;
 80a0cc6:	9603      	str	r6, [sp, #12]
    desc.funcKey = funcKey;
 80a0cc8:	9501      	str	r5, [sp, #4]
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
 80a0cca:	f7ff ff7d 	bl	80a0bc8 <spark_function>
}
 80a0cce:	b005      	add	sp, #20
 80a0cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a0cd2 <_ZN15EEPROMInitClassC1Ev>:
 */

/* Includes ------------------------------------------------------------------*/
#include "spark_wiring_eeprom.h"

EEPROMInitClass::EEPROMInitClass()
 80a0cd2:	b510      	push	{r4, lr}
 80a0cd4:	4604      	mov	r4, r0
{
    HAL_EEPROM_Init();
 80a0cd6:	f7ff fe3d 	bl	80a0954 <HAL_EEPROM_Init>
    void update( int idx, uint8_t val )  { EERef( idx ).update( val ); }

    //STL and C++11 iteration capability.
    EEPtr begin()                        { return 0x00; }
    EEPtr end()                          { return length(); } //Standards requires this to be the item after the last valid entry. The returned pointer is invalid.
    uint16_t length()                    { return HAL_EEPROM_Length(); }
 80a0cda:	f7ff fe43 	bl	80a0964 <HAL_EEPROM_Length>
    //Calling the below here just to get rid of compiler error: 'EEPROM' defined but not used
    EEPROM.length();
}
 80a0cde:	4620      	mov	r0, r4
 80a0ce0:	bd10      	pop	{r4, pc}

080a0ce2 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a0ce2:	4770      	bx	lr

080a0ce4 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a0ce4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0ce6:	4606      	mov	r6, r0
 80a0ce8:	4615      	mov	r5, r2
 80a0cea:	460c      	mov	r4, r1
 80a0cec:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0cee:	42bc      	cmp	r4, r7
 80a0cf0:	d006      	beq.n	80a0d00 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a0cf2:	6833      	ldr	r3, [r6, #0]
 80a0cf4:	4630      	mov	r0, r6
 80a0cf6:	689b      	ldr	r3, [r3, #8]
 80a0cf8:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a0cfc:	4798      	blx	r3
 80a0cfe:	e7f6      	b.n	80a0cee <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a0d00:	4628      	mov	r0, r5
 80a0d02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0d04 <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a0d04:	7c00      	ldrb	r0, [r0, #16]
 80a0d06:	2200      	movs	r2, #0
 80a0d08:	f7ff be84 	b.w	80a0a14 <HAL_I2C_Write_Data>

080a0d0c <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a0d0c:	7c00      	ldrb	r0, [r0, #16]
 80a0d0e:	2100      	movs	r1, #0
 80a0d10:	f7ff be88 	b.w	80a0a24 <HAL_I2C_Available_Data>

080a0d14 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a0d14:	7c00      	ldrb	r0, [r0, #16]
 80a0d16:	2100      	movs	r1, #0
 80a0d18:	f7ff be8c 	b.w	80a0a34 <HAL_I2C_Read_Data>

080a0d1c <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0d1c:	7c00      	ldrb	r0, [r0, #16]
 80a0d1e:	2100      	movs	r1, #0
 80a0d20:	f7ff be90 	b.w	80a0a44 <HAL_I2C_Peek_Data>

080a0d24 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a0d24:	7c00      	ldrb	r0, [r0, #16]
 80a0d26:	2100      	movs	r1, #0
 80a0d28:	f7ff be94 	b.w	80a0a54 <HAL_I2C_Flush_Data>

080a0d2c <_ZN7TwoWireD0Ev>:
 80a0d2c:	b510      	push	{r4, lr}
 80a0d2e:	4604      	mov	r4, r0
 80a0d30:	f7ff f9ae 	bl	80a0090 <_ZdlPv>
 80a0d34:	4620      	mov	r0, r4
 80a0d36:	bd10      	pop	{r4, pc}

080a0d38 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "spark_wiring_i2c.h"
#include "i2c_hal.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0d38:	b510      	push	{r4, lr}
 80a0d3a:	4604      	mov	r4, r0
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0d3c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a0d40:	6082      	str	r2, [r0, #8]
 80a0d42:	4a05      	ldr	r2, [pc, #20]	; (80a0d58 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0d44:	2300      	movs	r3, #0
 80a0d46:	6043      	str	r3, [r0, #4]
 80a0d48:	6002      	str	r2, [r0, #0]
{
  _i2c = i2c;
 80a0d4a:	7401      	strb	r1, [r0, #16]
  HAL_I2C_Init(_i2c, NULL);
 80a0d4c:	4608      	mov	r0, r1
 80a0d4e:	4619      	mov	r1, r3
 80a0d50:	f7ff fe90 	bl	80a0a74 <HAL_I2C_Init>
}
 80a0d54:	4620      	mov	r0, r4
 80a0d56:	bd10      	pop	{r4, pc}
 80a0d58:	080a19a0 	.word	0x080a19a0

080a0d5c <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a0d5c:	7c00      	ldrb	r0, [r0, #16]
 80a0d5e:	2100      	movs	r1, #0
 80a0d60:	f7ff be80 	b.w	80a0a64 <HAL_I2C_Is_Enabled>

080a0d64 <_Z10interruptsv>:
 * Return         : None.
 *******************************************************************************/
void interrupts(void)
{
  //Only enable the interrupts that are exposed to the user
  HAL_Interrupts_Enable_All();
 80a0d64:	f7ff be36 	b.w	80a09d4 <HAL_Interrupts_Enable_All>

080a0d68 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a0d68:	4770      	bx	lr

080a0d6a <_ZN9IPAddressD0Ev>:
 80a0d6a:	b510      	push	{r4, lr}
 80a0d6c:	4604      	mov	r4, r0
 80a0d6e:	f7ff f98f 	bl	80a0090 <_ZdlPv>
 80a0d72:	4620      	mov	r0, r4
 80a0d74:	bd10      	pop	{r4, pc}

080a0d76 <_ZNK9IPAddress7printToER5Print>:
{
    return memcmp(&this->address, &that.address, sizeof (address)) == 0;
}

size_t IPAddress::printTo(Print& p) const
{
 80a0d76:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0d78:	460f      	mov	r7, r1
 80a0d7a:	f100 0608 	add.w	r6, r0, #8
 80a0d7e:	1d05      	adds	r5, r0, #4
 80a0d80:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0d82:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a0d86:	4638      	mov	r0, r7
 80a0d88:	220a      	movs	r2, #10
 80a0d8a:	f000 f894 	bl	80a0eb6 <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0d8e:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0d90:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0d92:	d007      	beq.n	80a0da4 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a0d94:	2c00      	cmp	r4, #0
 80a0d96:	d0f4      	beq.n	80a0d82 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0d98:	4638      	mov	r0, r7
 80a0d9a:	212e      	movs	r1, #46	; 0x2e
 80a0d9c:	f000 f846 	bl	80a0e2c <_ZN5Print5printEc>
 80a0da0:	4404      	add	r4, r0
 80a0da2:	e7ee      	b.n	80a0d82 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a0da4:	4620      	mov	r0, r4
 80a0da6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0da8 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a0da8:	b510      	push	{r4, lr}
 80a0daa:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a0dae:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a0db2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a0db6:	ea42 6101 	orr.w	r1, r2, r1, lsl #24

    void set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3);

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a0dba:	2304      	movs	r3, #4
 80a0dbc:	6041      	str	r1, [r0, #4]
 80a0dbe:	7503      	strb	r3, [r0, #20]
 80a0dc0:	bd10      	pop	{r4, pc}
	...

080a0dc4 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a0dc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0dc6:	4604      	mov	r4, r0
 80a0dc8:	4d04      	ldr	r5, [pc, #16]	; (80a0ddc <_ZN9IPAddressC1Ehhhh+0x18>)
 80a0dca:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a0dcc:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a0dd0:	9500      	str	r5, [sp, #0]
 80a0dd2:	f7ff ffe9 	bl	80a0da8 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a0dd6:	4620      	mov	r0, r4
 80a0dd8:	b003      	add	sp, #12
 80a0dda:	bd30      	pop	{r4, r5, pc}
 80a0ddc:	080a19c8 	.word	0x080a19c8

080a0de0 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a0de0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0de2:	4606      	mov	r6, r0
 80a0de4:	460d      	mov	r5, r1
 80a0de6:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a0de8:	2400      	movs	r4, #0
  while (size--) {
 80a0dea:	42bd      	cmp	r5, r7
 80a0dec:	d00c      	beq.n	80a0e08 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a0dee:	6833      	ldr	r3, [r6, #0]
 80a0df0:	4630      	mov	r0, r6
 80a0df2:	689b      	ldr	r3, [r3, #8]
 80a0df4:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a0df8:	4798      	blx	r3
     if (chunk>=0)
 80a0dfa:	2800      	cmp	r0, #0
 80a0dfc:	db01      	blt.n	80a0e02 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a0dfe:	4404      	add	r4, r0
 80a0e00:	e7f3      	b.n	80a0dea <_ZN5Print5writeEPKhj+0xa>
/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     int chunk = write(*buffer++);
 80a0e02:	2c00      	cmp	r4, #0
 80a0e04:	bf08      	it	eq
 80a0e06:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a0e08:	4620      	mov	r0, r4
 80a0e0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0e0c <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a0e0c:	b570      	push	{r4, r5, r6, lr}
 80a0e0e:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a0e10:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a0e12:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a0e14:	b149      	cbz	r1, 80a0e2a <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a0e16:	f000 fcac 	bl	80a1772 <strlen>
 80a0e1a:	682b      	ldr	r3, [r5, #0]
 80a0e1c:	4602      	mov	r2, r0
 80a0e1e:	4621      	mov	r1, r4
 80a0e20:	4628      	mov	r0, r5
    }
 80a0e22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a0e26:	68db      	ldr	r3, [r3, #12]
 80a0e28:	4718      	bx	r3
    }
 80a0e2a:	bd70      	pop	{r4, r5, r6, pc}

080a0e2c <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a0e2c:	6803      	ldr	r3, [r0, #0]
 80a0e2e:	689b      	ldr	r3, [r3, #8]
 80a0e30:	4718      	bx	r3

080a0e32 <_ZN5Print7printlnEv>:
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a0e32:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a0e34:	210d      	movs	r1, #13
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a0e36:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a0e38:	f7ff fff8 	bl	80a0e2c <_ZN5Print5printEc>
  n += print('\n');
 80a0e3c:	210a      	movs	r1, #10
   return x.printTo(*this);
 }

size_t Print::println(void)
{
  size_t n = print('\r');
 80a0e3e:	4604      	mov	r4, r0
  n += print('\n');
 80a0e40:	4628      	mov	r0, r5
 80a0e42:	f7ff fff3 	bl	80a0e2c <_ZN5Print5printEc>
  return n;
}
 80a0e46:	4420      	add	r0, r4
 80a0e48:	bd38      	pop	{r3, r4, r5, pc}

080a0e4a <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a0e4a:	b538      	push	{r3, r4, r5, lr}
 80a0e4c:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0e4e:	f7ff ffdd 	bl	80a0e0c <_ZN5Print5writeEPKc>
 80a0e52:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a0e54:	4628      	mov	r0, r5
 80a0e56:	f7ff ffec 	bl	80a0e32 <_ZN5Print7printlnEv>
  return n;
}
 80a0e5a:	4420      	add	r0, r4
 80a0e5c:	bd38      	pop	{r3, r4, r5, pc}

080a0e5e <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a0e5e:	2a01      	cmp	r2, #1
 80a0e60:	bf98      	it	ls
 80a0e62:	220a      	movls	r2, #10
   return n;
 }

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a0e64:	b530      	push	{r4, r5, lr}
 80a0e66:	460b      	mov	r3, r1
 80a0e68:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a0e6a:	2100      	movs	r1, #0
 80a0e6c:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a0e70:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a0e74:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a0e78:	fb05 3312 	mls	r3, r5, r2, r3
 80a0e7c:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a0e7e:	2b09      	cmp	r3, #9
 80a0e80:	bf94      	ite	ls
 80a0e82:	3330      	addls	r3, #48	; 0x30
 80a0e84:	3337      	addhi	r3, #55	; 0x37
 80a0e86:	b2db      	uxtb	r3, r3
 80a0e88:	4621      	mov	r1, r4
 80a0e8a:	f804 3901 	strb.w	r3, [r4], #-1
 80a0e8e:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a0e90:	2d00      	cmp	r5, #0
 80a0e92:	d1ef      	bne.n	80a0e74 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a0e94:	f7ff ffba 	bl	80a0e0c <_ZN5Print5writeEPKc>
}
 80a0e98:	b00b      	add	sp, #44	; 0x2c
 80a0e9a:	bd30      	pop	{r4, r5, pc}

080a0e9c <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a0e9c:	b510      	push	{r4, lr}
  if (base == 0) return write(n);
 80a0e9e:	b92a      	cbnz	r2, 80a0eac <_ZN5Print5printEmi+0x10>
  else return printNumber(n, base);
}
 80a0ea0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a0ea4:	6803      	ldr	r3, [r0, #0]
 80a0ea6:	b2c9      	uxtb	r1, r1
 80a0ea8:	689b      	ldr	r3, [r3, #8]
 80a0eaa:	4718      	bx	r3
  else return printNumber(n, base);
 80a0eac:	b2d2      	uxtb	r2, r2
}
 80a0eae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a0eb2:	f7ff bfd4 	b.w	80a0e5e <_ZN5Print11printNumberEmh>

080a0eb6 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a0eb6:	f7ff bff1 	b.w	80a0e9c <_ZN5Print5printEmi>

080a0eba <_ZN5Servo17writeMicrosecondsEt>:
  // write(179).
  return a == this->minAngle || a == this->maxAngle ? a : a + 1;
}

void Servo::writeMicroseconds(uint16_t pulseWidth)
{
 80a0eba:	4602      	mov	r2, r0
 80a0ebc:	8800      	ldrh	r0, [r0, #0]

  if (!this->attached())
 80a0ebe:	b203      	sxth	r3, r0
 80a0ec0:	3301      	adds	r3, #1
 80a0ec2:	d00a      	beq.n	80a0eda <_ZN5Servo17writeMicrosecondsEt+0x20>
  {
    return;
  }

  pulseWidth = constrain(pulseWidth, this->minPW, this->maxPW);
 80a0ec4:	8853      	ldrh	r3, [r2, #2]
 80a0ec6:	8892      	ldrh	r2, [r2, #4]
typename std::common_type<T, U>::type
min (T a, U b) { return static_cast<typename std::common_type<T, U>::type>((a)<(b)?(a):(b)); }

template <typename T, typename U, typename V>
static inline
T constrain (T amt, U low, V high) { return ((amt)<(low)?(low):((amt)>(high)?(high):(amt))); }
 80a0ec8:	4299      	cmp	r1, r3
 80a0eca:	d303      	bcc.n	80a0ed4 <_ZN5Servo17writeMicrosecondsEt+0x1a>
 80a0ecc:	4291      	cmp	r1, r2
 80a0ece:	460b      	mov	r3, r1
 80a0ed0:	bf28      	it	cs
 80a0ed2:	4613      	movcs	r3, r2

  HAL_Servo_Write_Pulse_Width(this->pin, pulseWidth);
 80a0ed4:	4619      	mov	r1, r3
 80a0ed6:	f7ff bde7 	b.w	80a0aa8 <HAL_Servo_Write_Pulse_Width>
 80a0eda:	4770      	bx	lr

080a0edc <_ZN5Servo5writeEi>:

  return true;
}

void Servo::write(int degrees)
{
 80a0edc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0ede:	4604      	mov	r4, r0
 80a0ee0:	4608      	mov	r0, r1
 80a0ee2:	f9b4 1006 	ldrsh.w	r1, [r4, #6]
 80a0ee6:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
 80a0eea:	4288      	cmp	r0, r1
 80a0eec:	db03      	blt.n	80a0ef6 <_ZN5Servo5writeEi+0x1a>
 80a0eee:	4290      	cmp	r0, r2
 80a0ef0:	bfa8      	it	ge
 80a0ef2:	4610      	movge	r0, r2
 80a0ef4:	e000      	b.n	80a0ef8 <_ZN5Servo5writeEi+0x1c>
 80a0ef6:	4608      	mov	r0, r1
  degrees = constrain(degrees, this->minAngle, this->maxAngle);
  this->writeMicroseconds(ANGLE_TO_US(degrees)+trim);
 80a0ef8:	88a5      	ldrh	r5, [r4, #4]
 80a0efa:	8863      	ldrh	r3, [r4, #2]
 80a0efc:	9500      	str	r5, [sp, #0]
 80a0efe:	f7ff fea3 	bl	80a0c48 <map>
 80a0f02:	68e1      	ldr	r1, [r4, #12]
 80a0f04:	4401      	add	r1, r0
 80a0f06:	4620      	mov	r0, r4
 80a0f08:	b289      	uxth	r1, r1
}
 80a0f0a:	b003      	add	sp, #12
 80a0f0c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
}

void Servo::write(int degrees)
{
  degrees = constrain(degrees, this->minAngle, this->maxAngle);
  this->writeMicroseconds(ANGLE_TO_US(degrees)+trim);
 80a0f10:	f7ff bfd3 	b.w	80a0eba <_ZN5Servo17writeMicrosecondsEt>

080a0f14 <_ZN5Servo11resetFieldsEv>:
  return HAL_Servo_Read_Pulse_Width(this->pin);
}

void Servo::resetFields(void)
{
  this->pin = NOT_ATTACHED;
 80a0f14:	f64f 73ff 	movw	r3, #65535	; 0xffff
  this->minAngle = SERVO_DEFAULT_MIN_ANGLE;
  this->maxAngle = SERVO_DEFAULT_MAX_ANGLE;
 80a0f18:	22b4      	movs	r2, #180	; 0xb4
 80a0f1a:	8102      	strh	r2, [r0, #8]
  this->minPW = SERVO_DEFAULT_MIN_PW;
 80a0f1c:	f44f 7208 	mov.w	r2, #544	; 0x220
  return HAL_Servo_Read_Pulse_Width(this->pin);
}

void Servo::resetFields(void)
{
  this->pin = NOT_ATTACHED;
 80a0f20:	8003      	strh	r3, [r0, #0]
  this->minAngle = SERVO_DEFAULT_MIN_ANGLE;
  this->maxAngle = SERVO_DEFAULT_MAX_ANGLE;
  this->minPW = SERVO_DEFAULT_MIN_PW;
 80a0f22:	8042      	strh	r2, [r0, #2]
}

void Servo::resetFields(void)
{
  this->pin = NOT_ATTACHED;
  this->minAngle = SERVO_DEFAULT_MIN_ANGLE;
 80a0f24:	2300      	movs	r3, #0
  this->maxAngle = SERVO_DEFAULT_MAX_ANGLE;
  this->minPW = SERVO_DEFAULT_MIN_PW;
  this->maxPW = SERVO_DEFAULT_MAX_PW;
 80a0f26:	f44f 6216 	mov.w	r2, #2400	; 0x960
}

void Servo::resetFields(void)
{
  this->pin = NOT_ATTACHED;
  this->minAngle = SERVO_DEFAULT_MIN_ANGLE;
 80a0f2a:	80c3      	strh	r3, [r0, #6]
  this->maxAngle = SERVO_DEFAULT_MAX_ANGLE;
  this->minPW = SERVO_DEFAULT_MIN_PW;
  this->maxPW = SERVO_DEFAULT_MAX_PW;
 80a0f2c:	8082      	strh	r2, [r0, #4]
  this->trim = 0;
 80a0f2e:	60c3      	str	r3, [r0, #12]
 80a0f30:	4770      	bx	lr

080a0f32 <_ZN5ServoC1Ev>:
#define ANGLE_TO_US(a)    ((uint16_t)(map((a), this->minAngle, this->maxAngle, \
                                        this->minPW, this->maxPW)))
#define US_TO_ANGLE(us)   ((int16_t)(map((us), this->minPW, this->maxPW,  \
                                       this->minAngle, this->maxAngle)))

Servo::Servo()
 80a0f32:	b510      	push	{r4, lr}
 80a0f34:	4604      	mov	r4, r0
{
  this->resetFields();
 80a0f36:	f7ff ffed 	bl	80a0f14 <_ZN5Servo11resetFieldsEv>
}
 80a0f3a:	4620      	mov	r0, r4
 80a0f3c:	bd10      	pop	{r4, pc}

080a0f3e <_ZN5Servo6detachEv>:

  return true;
}

bool Servo::detach()
{
 80a0f3e:	b510      	push	{r4, lr}
 80a0f40:	4604      	mov	r4, r0
 80a0f42:	8800      	ldrh	r0, [r0, #0]
  if (!this->attached())
 80a0f44:	b203      	sxth	r3, r0
 80a0f46:	3301      	adds	r3, #1
 80a0f48:	d006      	beq.n	80a0f58 <_ZN5Servo6detachEv+0x1a>
  {
    return false;
  }

  HAL_Servo_Detach(this->pin);
 80a0f4a:	f7ff fda5 	bl	80a0a98 <HAL_Servo_Detach>

  this->resetFields();
 80a0f4e:	4620      	mov	r0, r4
 80a0f50:	f7ff ffe0 	bl	80a0f14 <_ZN5Servo11resetFieldsEv>

  return true;
 80a0f54:	2001      	movs	r0, #1
 80a0f56:	bd10      	pop	{r4, pc}

bool Servo::detach()
{
  if (!this->attached())
  {
    return false;
 80a0f58:	2000      	movs	r0, #0
  HAL_Servo_Detach(this->pin);

  this->resetFields();

  return true;
}
 80a0f5a:	bd10      	pop	{r4, pc}

080a0f5c <_ZN5Servo6attachEtttss>:
bool Servo::attach(uint16_t pin,
    uint16_t minPW,
    uint16_t maxPW,
    int16_t minAngle,
    int16_t maxAngle)
{
 80a0f5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0f60:	4604      	mov	r4, r0
 80a0f62:	460d      	mov	r5, r1

  if (HAL_Validate_Pin_Function(pin, PF_TIMER)!=PF_TIMER)
 80a0f64:	4608      	mov	r0, r1
 80a0f66:	2102      	movs	r1, #2
bool Servo::attach(uint16_t pin,
    uint16_t minPW,
    uint16_t maxPW,
    int16_t minAngle,
    int16_t maxAngle)
{
 80a0f68:	4690      	mov	r8, r2
 80a0f6a:	461f      	mov	r7, r3

  if (HAL_Validate_Pin_Function(pin, PF_TIMER)!=PF_TIMER)
 80a0f6c:	f7ff fd0a 	bl	80a0984 <HAL_Validate_Pin_Function>
 80a0f70:	2802      	cmp	r0, #2
 80a0f72:	d001      	beq.n	80a0f78 <_ZN5Servo6attachEtttss+0x1c>
  {
    return false;
 80a0f74:	2600      	movs	r6, #0
 80a0f76:	e019      	b.n	80a0fac <_ZN5Servo6attachEtttss+0x50>
  }

  // Safety check
  if (!pinAvailable(pin))
 80a0f78:	4628      	mov	r0, r5
 80a0f7a:	f000 f9ed 	bl	80a1358 <pinAvailable>
 80a0f7e:	4606      	mov	r6, r0
 80a0f80:	2800      	cmp	r0, #0
 80a0f82:	d0f7      	beq.n	80a0f74 <_ZN5Servo6attachEtttss+0x18>
  {
    return false;
  }

  if (this->attached())
 80a0f84:	f9b4 3000 	ldrsh.w	r3, [r4]
 80a0f88:	3301      	adds	r3, #1
 80a0f8a:	d002      	beq.n	80a0f92 <_ZN5Servo6attachEtttss+0x36>
  {
    this->detach();
 80a0f8c:	4620      	mov	r0, r4
 80a0f8e:	f7ff ffd6 	bl	80a0f3e <_ZN5Servo6detachEv>
  }

  this->pin = pin;
  this->minPW = minPW;
  this->maxPW = maxPW;
  this->minAngle = minAngle;
 80a0f92:	f9bd 3018 	ldrsh.w	r3, [sp, #24]
  if (this->attached())
  {
    this->detach();
  }

  this->pin = pin;
 80a0f96:	8025      	strh	r5, [r4, #0]
  this->minPW = minPW;
  this->maxPW = maxPW;
  this->minAngle = minAngle;
 80a0f98:	80e3      	strh	r3, [r4, #6]
  this->maxAngle = maxAngle;
 80a0f9a:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
  {
    this->detach();
  }

  this->pin = pin;
  this->minPW = minPW;
 80a0f9e:	f8a4 8002 	strh.w	r8, [r4, #2]
  this->maxPW = maxPW;
 80a0fa2:	80a7      	strh	r7, [r4, #4]
  this->minAngle = minAngle;
  this->maxAngle = maxAngle;
 80a0fa4:	8123      	strh	r3, [r4, #8]

  HAL_Servo_Attach(this->pin);
 80a0fa6:	4628      	mov	r0, r5
 80a0fa8:	f7ff fd6e 	bl	80a0a88 <HAL_Servo_Attach>

  return true;
}
 80a0fac:	4630      	mov	r0, r6
 80a0fae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a0fb2 <_ZN8SPIClassD1Ev>:
   */
  unsigned dividerReference;

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a0fb2:	4770      	bx	lr

080a0fb4 <_ZN8SPIClassD0Ev>:
 80a0fb4:	b510      	push	{r4, lr}
 80a0fb6:	4604      	mov	r4, r0
 80a0fb8:	f7ff f86a 	bl	80a0090 <_ZdlPv>
 80a0fbc:	4620      	mov	r0, r4
 80a0fbe:	bd10      	pop	{r4, pc}

080a0fc0 <_ZN8SPIClassC1E17HAL_SPI_Interface>:

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0fc0:	b510      	push	{r4, lr}
 80a0fc2:	4604      	mov	r4, r0
 80a0fc4:	4b04      	ldr	r3, [pc, #16]	; (80a0fd8 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x18>)
{
  _spi = spi;
 80a0fc6:	7101      	strb	r1, [r0, #4]

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0fc8:	6003      	str	r3, [r0, #0]
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a0fca:	4608      	mov	r0, r1
 80a0fcc:	f7ff fd74 	bl	80a0ab8 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a0fd0:	2300      	movs	r3, #0
 80a0fd2:	60a3      	str	r3, [r4, #8]
}
 80a0fd4:	4620      	mov	r0, r4
 80a0fd6:	bd10      	pop	{r4, pc}
 80a0fd8:	080a19e0 	.word	0x080a19e0

080a0fdc <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a0fdc:	7900      	ldrb	r0, [r0, #4]
 80a0fde:	f7ff bd73 	b.w	80a0ac8 <HAL_SPI_Is_Enabled>

080a0fe2 <_ZN6StringC1EOS_>:
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a0fe2:	2300      	movs	r3, #0
 80a0fe4:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a0fe6:	6043      	str	r3, [r0, #4]
	len = 0;
 80a0fe8:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a0fea:	7303      	strb	r3, [r0, #12]
	init();
	*this = value;
}

#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
 80a0fec:	b510      	push	{r4, lr}
			return;
		} else {
			free(buffer);
		}
	}
	buffer = rhs.buffer;
 80a0fee:	680c      	ldr	r4, [r1, #0]
 80a0ff0:	6004      	str	r4, [r0, #0]
	capacity = rhs.capacity;
 80a0ff2:	684c      	ldr	r4, [r1, #4]
 80a0ff4:	6044      	str	r4, [r0, #4]
	len = rhs.len;
 80a0ff6:	688c      	ldr	r4, [r1, #8]
 80a0ff8:	6084      	str	r4, [r0, #8]
	rhs.buffer = NULL;
 80a0ffa:	600b      	str	r3, [r1, #0]
	rhs.capacity = 0;
 80a0ffc:	604b      	str	r3, [r1, #4]
	rhs.len = 0;
 80a0ffe:	608b      	str	r3, [r1, #8]
#ifdef __GXX_EXPERIMENTAL_CXX0X__
String::String(String &&rval)
{
	init();
	move(rval);
}
 80a1000:	bd10      	pop	{r4, pc}

080a1002 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a1002:	b510      	push	{r4, lr}
 80a1004:	4604      	mov	r4, r0
{
	free(buffer);
 80a1006:	6800      	ldr	r0, [r0, #0]
 80a1008:	f7ff fe06 	bl	80a0c18 <free>
}
 80a100c:	4620      	mov	r0, r4
 80a100e:	bd10      	pop	{r4, pc}

080a1010 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a1010:	b510      	push	{r4, lr}
 80a1012:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a1014:	6800      	ldr	r0, [r0, #0]
 80a1016:	b108      	cbz	r0, 80a101c <_ZN6String10invalidateEv+0xc>
 80a1018:	f7ff fdfe 	bl	80a0c18 <free>
	buffer = NULL;
 80a101c:	2300      	movs	r3, #0
 80a101e:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a1020:	60a3      	str	r3, [r4, #8]
 80a1022:	6063      	str	r3, [r4, #4]
 80a1024:	bd10      	pop	{r4, pc}

080a1026 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a1026:	b538      	push	{r3, r4, r5, lr}
 80a1028:	4604      	mov	r4, r0
 80a102a:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a102c:	6800      	ldr	r0, [r0, #0]
 80a102e:	3101      	adds	r1, #1
 80a1030:	f7ff fdfa 	bl	80a0c28 <realloc>
	if (newbuffer) {
 80a1034:	b110      	cbz	r0, 80a103c <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a1036:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a103a:	2001      	movs	r0, #1
	}
	return 0;
}
 80a103c:	bd38      	pop	{r3, r4, r5, pc}

080a103e <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a103e:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a1040:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a1042:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a1044:	b113      	cbz	r3, 80a104c <_ZN6String7reserveEj+0xe>
 80a1046:	6843      	ldr	r3, [r0, #4]
 80a1048:	428b      	cmp	r3, r1
 80a104a:	d207      	bcs.n	80a105c <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a104c:	4620      	mov	r0, r4
 80a104e:	f7ff ffea 	bl	80a1026 <_ZN6String12changeBufferEj>
 80a1052:	b120      	cbz	r0, 80a105e <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a1054:	68a3      	ldr	r3, [r4, #8]
 80a1056:	b90b      	cbnz	r3, 80a105c <_ZN6String7reserveEj+0x1e>
 80a1058:	6822      	ldr	r2, [r4, #0]
 80a105a:	7013      	strb	r3, [r2, #0]
 80a105c:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a105e:	bd10      	pop	{r4, pc}

080a1060 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a1060:	b570      	push	{r4, r5, r6, lr}
 80a1062:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a1064:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a1066:	4604      	mov	r4, r0
 80a1068:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a106a:	f7ff ffe8 	bl	80a103e <_ZN6String7reserveEj>
 80a106e:	b918      	cbnz	r0, 80a1078 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a1070:	4620      	mov	r0, r4
 80a1072:	f7ff ffcd 	bl	80a1010 <_ZN6String10invalidateEv>
		return *this;
 80a1076:	e004      	b.n	80a1082 <_ZN6String4copyEPKcj+0x22>
	}
	len = length;
 80a1078:	60a5      	str	r5, [r4, #8]
	strcpy(buffer, cstr);
 80a107a:	6820      	ldr	r0, [r4, #0]
 80a107c:	4631      	mov	r1, r6
 80a107e:	f000 fb70 	bl	80a1762 <strcpy>
	return *this;
}
 80a1082:	4620      	mov	r0, r4
 80a1084:	bd70      	pop	{r4, r5, r6, pc}

080a1086 <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
 80a1086:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a1088:	2300      	movs	r3, #0

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
 80a108a:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a108c:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a108e:	6043      	str	r3, [r0, #4]
	len = 0;
 80a1090:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a1092:	7303      	strb	r3, [r0, #12]
/*********************************************/

String::String(const char *cstr)
{
	init();
	if (cstr) copy(cstr, strlen(cstr));
 80a1094:	460d      	mov	r5, r1
 80a1096:	b139      	cbz	r1, 80a10a8 <_ZN6StringC1EPKc+0x22>
 80a1098:	4608      	mov	r0, r1
 80a109a:	f000 fb6a 	bl	80a1772 <strlen>
 80a109e:	4629      	mov	r1, r5
 80a10a0:	4602      	mov	r2, r0
 80a10a2:	4620      	mov	r0, r4
 80a10a4:	f7ff ffdc 	bl	80a1060 <_ZN6String4copyEPKcj>
}
 80a10a8:	4620      	mov	r0, r4
 80a10aa:	bd38      	pop	{r3, r4, r5, pc}

080a10ac <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a10ac:	b538      	push	{r3, r4, r5, lr}
 80a10ae:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a10b0:	460c      	mov	r4, r1
 80a10b2:	b141      	cbz	r1, 80a10c6 <_ZN6StringaSEPKc+0x1a>
 80a10b4:	4608      	mov	r0, r1
 80a10b6:	f000 fb5c 	bl	80a1772 <strlen>
 80a10ba:	4621      	mov	r1, r4
 80a10bc:	4602      	mov	r2, r0
 80a10be:	4628      	mov	r0, r5
 80a10c0:	f7ff ffce 	bl	80a1060 <_ZN6String4copyEPKcj>
 80a10c4:	e001      	b.n	80a10ca <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a10c6:	f7ff ffa3 	bl	80a1010 <_ZN6String10invalidateEv>

	return *this;
}
 80a10ca:	4628      	mov	r0, r5
 80a10cc:	bd38      	pop	{r3, r4, r5, pc}

080a10ce <_ZN6StringC1Elh>:
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
 80a10ce:	b510      	push	{r4, lr}
 80a10d0:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a10d2:	2300      	movs	r3, #0
	char buf[33];
	utoa(value, buf, base);
	*this = buf;
}

String::String(long value, unsigned char base)
 80a10d4:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a10d6:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a10d8:	6043      	str	r3, [r0, #4]
	len = 0;
 80a10da:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a10dc:	7303      	strb	r3, [r0, #12]

String::String(long value, unsigned char base)
{
	init();
	char buf[34];
	ltoa(value, buf, base);
 80a10de:	4608      	mov	r0, r1
 80a10e0:	a901      	add	r1, sp, #4
 80a10e2:	f000 f8fb 	bl	80a12dc <ltoa>
	*this = buf;
 80a10e6:	4620      	mov	r0, r4
 80a10e8:	a901      	add	r1, sp, #4
 80a10ea:	f7ff ffdf 	bl	80a10ac <_ZN6StringaSEPKc>
}
 80a10ee:	4620      	mov	r0, r4
 80a10f0:	b00a      	add	sp, #40	; 0x28
 80a10f2:	bd10      	pop	{r4, pc}

080a10f4 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a10f4:	b570      	push	{r4, r5, r6, lr}
 80a10f6:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
 80a10f8:	6883      	ldr	r3, [r0, #8]
	if (!cstr) return 0;
 80a10fa:	460e      	mov	r6, r1
 80a10fc:	b909      	cbnz	r1, 80a1102 <_ZN6String6concatEPKcj+0xe>
 80a10fe:	2000      	movs	r0, #0
 80a1100:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a1102:	b162      	cbz	r2, 80a111e <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a1104:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a1106:	4629      	mov	r1, r5
 80a1108:	f7ff ff99 	bl	80a103e <_ZN6String7reserveEj>
 80a110c:	2800      	cmp	r0, #0
 80a110e:	d0f6      	beq.n	80a10fe <_ZN6String6concatEPKcj+0xa>
	strcpy(buffer + len, cstr);
 80a1110:	6820      	ldr	r0, [r4, #0]
 80a1112:	68a3      	ldr	r3, [r4, #8]
 80a1114:	4631      	mov	r1, r6
 80a1116:	4418      	add	r0, r3
 80a1118:	f000 fb23 	bl	80a1762 <strcpy>
	len = newlen;
 80a111c:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a111e:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a1120:	bd70      	pop	{r4, r5, r6, pc}

080a1122 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a1122:	460b      	mov	r3, r1
 80a1124:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a1126:	689a      	ldr	r2, [r3, #8]
 80a1128:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a112a:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a112c:	f7ff ffe2 	bl	80a10f4 <_ZN6String6concatEPKcj>
 80a1130:	b910      	cbnz	r0, 80a1138 <_ZplRK15StringSumHelperRK6String+0x16>
 80a1132:	4620      	mov	r0, r4
 80a1134:	f7ff ff6c 	bl	80a1010 <_ZN6String10invalidateEv>
	return a;
}
 80a1138:	4620      	mov	r0, r4
 80a113a:	bd10      	pop	{r4, pc}

080a113c <_ZNK6String9substringEjj>:
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a113c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a1140:	461c      	mov	r4, r3
	if (left > right) {
 80a1142:	429a      	cmp	r2, r3
 80a1144:	bf88      	it	hi
 80a1146:	4613      	movhi	r3, r2
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a1148:	460e      	mov	r6, r1
 80a114a:	4615      	mov	r5, r2
	if (left > right) {
 80a114c:	bf88      	it	hi
 80a114e:	4625      	movhi	r5, r4
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a1150:	490d      	ldr	r1, [pc, #52]	; (80a1188 <_ZNK6String9substringEjj+0x4c>)
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
	if (left > right) {
 80a1152:	bf88      	it	hi
 80a1154:	461c      	movhi	r4, r3
{
	return substring(left, len);
}

String String::substring(unsigned int left, unsigned int right) const
{
 80a1156:	4607      	mov	r7, r0
	if (left > right) {
		unsigned int temp = right;
		right = left;
		left = temp;
	}
	String out;
 80a1158:	f7ff ff95 	bl	80a1086 <_ZN6StringC1EPKc>
	if (left > len) return out;
 80a115c:	68b1      	ldr	r1, [r6, #8]
 80a115e:	428d      	cmp	r5, r1
 80a1160:	d80f      	bhi.n	80a1182 <_ZNK6String9substringEjj+0x46>
 80a1162:	428c      	cmp	r4, r1
 80a1164:	bf28      	it	cs
 80a1166:	460c      	movcs	r4, r1
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a1168:	6833      	ldr	r3, [r6, #0]
	buffer[right] = '\0';
 80a116a:	2200      	movs	r2, #0
		left = temp;
	}
	String out;
	if (left > len) return out;
	if (right > len) right = len;
	char temp = buffer[right];  // save the replaced character
 80a116c:	f813 8004 	ldrb.w	r8, [r3, r4]
	buffer[right] = '\0';
 80a1170:	551a      	strb	r2, [r3, r4]
	out = buffer + left;  // pointer arithmetic
 80a1172:	6831      	ldr	r1, [r6, #0]
 80a1174:	4638      	mov	r0, r7
 80a1176:	4429      	add	r1, r5
 80a1178:	f7ff ff98 	bl	80a10ac <_ZN6StringaSEPKc>
	buffer[right] = temp;  //restore character
 80a117c:	6833      	ldr	r3, [r6, #0]
 80a117e:	f803 8004 	strb.w	r8, [r3, r4]
	return out;
}
 80a1182:	4638      	mov	r0, r7
 80a1184:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a1188:	080a1938 	.word	0x080a1938

080a118c <_ZNK6String5toIntEv>:
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const
{
	if (buffer) return atol(buffer);
 80a118c:	6800      	ldr	r0, [r0, #0]
 80a118e:	b108      	cbz	r0, 80a1194 <_ZNK6String5toIntEv+0x8>
 80a1190:	f000 baa4 	b.w	80a16dc <atol>
	return 0;
}
 80a1194:	4770      	bx	lr

080a1196 <_GLOBAL__sub_I_System>:

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a1196:	2000      	movs	r0, #0
 80a1198:	f7ff bcf6 	b.w	80a0b88 <set_system_mode>

080a119c <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a119c:	4b02      	ldr	r3, [pc, #8]	; (80a11a8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a119e:	681a      	ldr	r2, [r3, #0]
 80a11a0:	4b02      	ldr	r3, [pc, #8]	; (80a11ac <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a11a2:	601a      	str	r2, [r3, #0]
 80a11a4:	4770      	bx	lr
 80a11a6:	bf00      	nop
 80a11a8:	20000300 	.word	0x20000300
 80a11ac:	200003d0 	.word	0x200003d0

080a11b0 <_ZN11USARTSerialD1Ev>:
{
private:
  HAL_USART_Serial _serial;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a11b0:	4770      	bx	lr

080a11b2 <_ZN11USARTSerial9availableEv>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a11b2:	7c00      	ldrb	r0, [r0, #16]
 80a11b4:	f7ff bcc0 	b.w	80a0b38 <HAL_USART_Available_Data>

080a11b8 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a11b8:	7c00      	ldrb	r0, [r0, #16]
 80a11ba:	f7ff bccd 	b.w	80a0b58 <HAL_USART_Peek_Data>

080a11be <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a11be:	7c00      	ldrb	r0, [r0, #16]
 80a11c0:	f7ff bcc2 	b.w	80a0b48 <HAL_USART_Read_Data>

080a11c4 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a11c4:	7c00      	ldrb	r0, [r0, #16]
 80a11c6:	f7ff bccf 	b.w	80a0b68 <HAL_USART_Flush_Data>

080a11ca <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
  return HAL_USART_Write_Data(_serial, c);
 80a11ca:	7c00      	ldrb	r0, [r0, #16]
 80a11cc:	f7ff bcac 	b.w	80a0b28 <HAL_USART_Write_Data>

080a11d0 <_ZN11USARTSerialD0Ev>:
 80a11d0:	b510      	push	{r4, lr}
 80a11d2:	4604      	mov	r4, r0
 80a11d4:	f7fe ff5c 	bl	80a0090 <_ZdlPv>
 80a11d8:	4620      	mov	r0, r4
 80a11da:	bd10      	pop	{r4, pc}

080a11dc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a11dc:	b510      	push	{r4, lr}
 80a11de:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a11e0:	2000      	movs	r0, #0
 80a11e2:	6060      	str	r0, [r4, #4]
 80a11e4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a11e8:	60a0      	str	r0, [r4, #8]
 80a11ea:	4805      	ldr	r0, [pc, #20]	; (80a1200 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x24>)
{
  _serial = serial;
 80a11ec:	7421      	strb	r1, [r4, #16]
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a11ee:	6020      	str	r0, [r4, #0]
{
  _serial = serial;
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a11f0:	4608      	mov	r0, r1
 80a11f2:	4611      	mov	r1, r2
 80a11f4:	461a      	mov	r2, r3
 80a11f6:	f7ff fc8f 	bl	80a0b18 <HAL_USART_Init>
}
 80a11fa:	4620      	mov	r0, r4
 80a11fc:	bd10      	pop	{r4, pc}
 80a11fe:	bf00      	nop
 80a1200:	080a1a20 	.word	0x080a1a20

080a1204 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a1204:	7c00      	ldrb	r0, [r0, #16]
 80a1206:	f7ff bcb7 	b.w	80a0b78 <HAL_USART_Is_Enabled>
	...

080a120c <_GLOBAL__sub_I__ZN11USARTSerialC2E16HAL_USART_SerialP11Ring_BufferS2_>:
// Preinstantiate Objects //////////////////////////////////////////////////////
static Ring_Buffer serial1_rx_buffer;
static Ring_Buffer serial1_tx_buffer;


USARTSerial Serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a120c:	b510      	push	{r4, lr}
 80a120e:	4c07      	ldr	r4, [pc, #28]	; (80a122c <_GLOBAL__sub_I__ZN11USARTSerialC2E16HAL_USART_SerialP11Ring_BufferS2_+0x20>)
 80a1210:	2100      	movs	r1, #0
 80a1212:	4620      	mov	r0, r4
 80a1214:	4a06      	ldr	r2, [pc, #24]	; (80a1230 <_GLOBAL__sub_I__ZN11USARTSerialC2E16HAL_USART_SerialP11Ring_BufferS2_+0x24>)
 80a1216:	4b07      	ldr	r3, [pc, #28]	; (80a1234 <_GLOBAL__sub_I__ZN11USARTSerialC2E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
 80a1218:	f7ff ffe0 	bl	80a11dc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a121c:	4620      	mov	r0, r4
 80a121e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1222:	4905      	ldr	r1, [pc, #20]	; (80a1238 <_GLOBAL__sub_I__ZN11USARTSerialC2E16HAL_USART_SerialP11Ring_BufferS2_+0x2c>)
 80a1224:	4a05      	ldr	r2, [pc, #20]	; (80a123c <_GLOBAL__sub_I__ZN11USARTSerialC2E16HAL_USART_SerialP11Ring_BufferS2_+0x30>)
 80a1226:	f000 b98b 	b.w	80a1540 <__aeabi_atexit>
 80a122a:	bf00      	nop
 80a122c:	200003d4 	.word	0x200003d4
 80a1230:	2000042a 	.word	0x2000042a
 80a1234:	200003e8 	.word	0x200003e8
 80a1238:	080a11b1 	.word	0x080a11b1
 80a123c:	2000036c 	.word	0x2000036c

080a1240 <_ZN9USBSerial5flushEv>:
	USB_USART_Send_Data(byte);
	return 1;
}

void USBSerial::flush()
{
 80a1240:	4770      	bx	lr

080a1242 <_ZN9USBSerialD1Ev>:
#define __SPARK_WIRING_USBSERIAL_H

#include "spark_wiring_stream.h"
#include "usb_hal.h"

class USBSerial : public Stream
 80a1242:	4770      	bx	lr

080a1244 <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return USB_USART_Receive_Data(false);
 80a1244:	2000      	movs	r0, #0
 80a1246:	f7ff bc57 	b.w	80a0af8 <USB_USART_Receive_Data>

080a124a <_ZN9USBSerial4peekEv>:
{
}

int USBSerial::peek()
{
	return USB_USART_Receive_Data(true);
 80a124a:	2001      	movs	r0, #1
 80a124c:	f7ff bc54 	b.w	80a0af8 <USB_USART_Receive_Data>

080a1250 <_ZN9USBSerial9availableEv>:
{
	return USB_USART_Receive_Data(false);
}

int USBSerial::available()
{
 80a1250:	b508      	push	{r3, lr}
	return USB_USART_Available_Data();
 80a1252:	f7ff fc49 	bl	80a0ae8 <USB_USART_Available_Data>
}
 80a1256:	bd08      	pop	{r3, pc}

080a1258 <_ZN9USBSerial5writeEh>:

size_t USBSerial::write(uint8_t byte)
{
 80a1258:	b508      	push	{r3, lr}
	USB_USART_Send_Data(byte);
 80a125a:	4608      	mov	r0, r1
 80a125c:	f7ff fc54 	bl	80a0b08 <USB_USART_Send_Data>
	return 1;
}
 80a1260:	2001      	movs	r0, #1
 80a1262:	bd08      	pop	{r3, pc}

080a1264 <_ZN9USBSerialD0Ev>:
 80a1264:	b510      	push	{r4, lr}
 80a1266:	4604      	mov	r4, r0
 80a1268:	f7fe ff12 	bl	80a0090 <_ZdlPv>
 80a126c:	4620      	mov	r0, r4
 80a126e:	bd10      	pop	{r4, pc}

080a1270 <_ZN9USBSerialC1Ev>:
 80a1270:	2200      	movs	r2, #0
 80a1272:	6042      	str	r2, [r0, #4]
 80a1274:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a1278:	6082      	str	r2, [r0, #8]
#include "spark_wiring_usbserial.h"

//
// Constructor
//
USBSerial::USBSerial()
 80a127a:	4a01      	ldr	r2, [pc, #4]	; (80a1280 <_ZN9USBSerialC1Ev+0x10>)
 80a127c:	6002      	str	r2, [r0, #0]
{
}
 80a127e:	4770      	bx	lr
 80a1280:	080a1a48 	.word	0x080a1a48

080a1284 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    USB_USART_Init((unsigned)speed);
 80a1284:	4608      	mov	r0, r1
 80a1286:	f7ff bc27 	b.w	80a0ad8 <USB_USART_Init>
	...

080a128c <_GLOBAL__sub_I__ZN9USBSerialC2Ev>:
	return USB_USART_Receive_Data(true);
}

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL
USBSerial Serial;
 80a128c:	b510      	push	{r4, lr}
 80a128e:	4c05      	ldr	r4, [pc, #20]	; (80a12a4 <_GLOBAL__sub_I__ZN9USBSerialC2Ev+0x18>)
 80a1290:	4620      	mov	r0, r4
 80a1292:	f7ff ffed 	bl	80a1270 <_ZN9USBSerialC1Ev>
 80a1296:	4620      	mov	r0, r4
 80a1298:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a129c:	4902      	ldr	r1, [pc, #8]	; (80a12a8 <_GLOBAL__sub_I__ZN9USBSerialC2Ev+0x1c>)
 80a129e:	4a03      	ldr	r2, [pc, #12]	; (80a12ac <_GLOBAL__sub_I__ZN9USBSerialC2Ev+0x20>)
 80a12a0:	f000 b94e 	b.w	80a1540 <__aeabi_atexit>
 80a12a4:	2000046c 	.word	0x2000046c
 80a12a8:	080a1243 	.word	0x080a1243
 80a12ac:	2000036c 	.word	0x2000036c

080a12b0 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a12b0:	4770      	bx	lr

080a12b2 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a12b2:	2000      	movs	r0, #0
 80a12b4:	4601      	mov	r1, r0
 80a12b6:	4602      	mov	r2, r0
 80a12b8:	f7ff bc9e 	b.w	80a0bf8 <network_ready>

080a12bc <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a12bc:	4803      	ldr	r0, [pc, #12]	; (80a12cc <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x10>)
 80a12be:	4b04      	ldr	r3, [pc, #16]	; (80a12d0 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a12c0:	4904      	ldr	r1, [pc, #16]	; (80a12d4 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x18>)
 80a12c2:	4a05      	ldr	r2, [pc, #20]	; (80a12d8 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x1c>)
 80a12c4:	6003      	str	r3, [r0, #0]
 80a12c6:	f000 b93b 	b.w	80a1540 <__aeabi_atexit>
 80a12ca:	bf00      	nop
 80a12cc:	2000047c 	.word	0x2000047c
 80a12d0:	080a1a70 	.word	0x080a1a70
 80a12d4:	080a12b1 	.word	0x080a12b1
 80a12d8:	2000036c 	.word	0x2000036c

080a12dc <ltoa>:



//convert long to string
char *ltoa(long N, char *str, int base)
{
 80a12dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a12e0:	4615      	mov	r5, r2
      int i = 2;
      long uarg;
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
 80a12e2:	3a02      	subs	r2, #2
            base = 10;                    /* can only use 0-9, A-Z        */
 80a12e4:	2a23      	cmp	r2, #35	; 0x23
 80a12e6:	bf28      	it	cs
 80a12e8:	250a      	movcs	r5, #10



//convert long to string
char *ltoa(long N, char *str, int base)
{
 80a12ea:	b08c      	sub	sp, #48	; 0x30
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
      tail = &buf[BUFSIZE - 1];           /* last character position      */
      *tail-- = '\0';
 80a12ec:	2200      	movs	r2, #0

      if (10 == base && N < 0L)
 80a12ee:	2d0a      	cmp	r5, #10



//convert long to string
char *ltoa(long N, char *str, int base)
{
 80a12f0:	4603      	mov	r3, r0
 80a12f2:	460c      	mov	r4, r1
      char *tail, *head = str, buf[BUFSIZE];

      if (36 < base || 2 > base)
            base = 10;                    /* can only use 0-9, A-Z        */
      tail = &buf[BUFSIZE - 1];           /* last character position      */
      *tail-- = '\0';
 80a12f4:	f88d 202c 	strb.w	r2, [sp, #44]	; 0x2c

      if (10 == base && N < 0L)
 80a12f8:	d107      	bne.n	80a130a <ltoa+0x2e>
 80a12fa:	4290      	cmp	r0, r2
 80a12fc:	da05      	bge.n	80a130a <ltoa+0x2e>
      {
            *head++ = '-';
 80a12fe:	222d      	movs	r2, #45	; 0x2d
 80a1300:	f101 0801 	add.w	r8, r1, #1
 80a1304:	700a      	strb	r2, [r1, #0]
            uarg    = -N;
 80a1306:	4243      	negs	r3, r0
 80a1308:	e001      	b.n	80a130e <ltoa+0x32>
      }
      else  uarg = N;

      if (uarg)
 80a130a:	b1ab      	cbz	r3, 80a1338 <ltoa+0x5c>
 80a130c:	46a0      	mov	r8, r4
 80a130e:	f10d 072b 	add.w	r7, sp, #43	; 0x2b
 80a1312:	2601      	movs	r6, #1
      {
            for (i = 1; uarg; ++i)
            {
                  ldiv_t r;

                  r       = ldiv(uarg, base);
 80a1314:	4619      	mov	r1, r3
 80a1316:	462a      	mov	r2, r5
 80a1318:	a801      	add	r0, sp, #4
 80a131a:	f000 f9f1 	bl	80a1700 <ldiv>
 80a131e:	9a02      	ldr	r2, [sp, #8]
      }
      else  uarg = N;

      if (uarg)
      {
            for (i = 1; uarg; ++i)
 80a1320:	3601      	adds	r6, #1
            {
                  ldiv_t r;

                  r       = ldiv(uarg, base);
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
 80a1322:	2a09      	cmp	r2, #9
 80a1324:	bfcc      	ite	gt
 80a1326:	2337      	movgt	r3, #55	; 0x37
 80a1328:	2330      	movle	r3, #48	; 0x30
 80a132a:	4413      	add	r3, r2
 80a132c:	f807 3901 	strb.w	r3, [r7], #-1
                  uarg    = r.quot;
 80a1330:	9b01      	ldr	r3, [sp, #4]
      }
      else  uarg = N;

      if (uarg)
      {
            for (i = 1; uarg; ++i)
 80a1332:	2b00      	cmp	r3, #0
 80a1334:	d1ee      	bne.n	80a1314 <ltoa+0x38>
 80a1336:	e006      	b.n	80a1346 <ltoa+0x6a>
                  *tail-- = (char)(r.rem + ((9L < r.rem) ?
                                  ('A' - 10L) : '0'));
                  uarg    = r.quot;
            }
      }
      else  *tail-- = '0';
 80a1338:	46a0      	mov	r8, r4
 80a133a:	2330      	movs	r3, #48	; 0x30
 80a133c:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 80a1340:	f10d 072a 	add.w	r7, sp, #42	; 0x2a


//convert long to string
char *ltoa(long N, char *str, int base)
{
      int i = 2;
 80a1344:	2602      	movs	r6, #2
                  uarg    = r.quot;
            }
      }
      else  *tail-- = '0';

      memcpy(head, ++tail, i);
 80a1346:	4640      	mov	r0, r8
 80a1348:	1c79      	adds	r1, r7, #1
 80a134a:	4632      	mov	r2, r6
 80a134c:	f000 f9ec 	bl	80a1728 <memcpy>
      return str;
}
 80a1350:	4620      	mov	r0, r4
 80a1352:	b00c      	add	sp, #48	; 0x30
 80a1354:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a1358 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a1358:	b510      	push	{r4, lr}
 80a135a:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a135c:	480e      	ldr	r0, [pc, #56]	; (80a1398 <pinAvailable+0x40>)
 80a135e:	f7ff fe3d 	bl	80a0fdc <_ZN8SPIClass9isEnabledEv>
 80a1362:	b128      	cbz	r0, 80a1370 <pinAvailable+0x18>
 80a1364:	f1a4 030d 	sub.w	r3, r4, #13
 80a1368:	2b02      	cmp	r3, #2
 80a136a:	d801      	bhi.n	80a1370 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a136c:	2000      	movs	r0, #0
 80a136e:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a1370:	480a      	ldr	r0, [pc, #40]	; (80a139c <pinAvailable+0x44>)
 80a1372:	f7ff fcf3 	bl	80a0d5c <_ZN7TwoWire9isEnabledEv>
 80a1376:	b108      	cbz	r0, 80a137c <pinAvailable+0x24>
 80a1378:	2c01      	cmp	r4, #1
 80a137a:	d9f7      	bls.n	80a136c <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a137c:	4808      	ldr	r0, [pc, #32]	; (80a13a0 <pinAvailable+0x48>)
 80a137e:	f7ff ff41 	bl	80a1204 <_ZN11USARTSerial9isEnabledEv>
 80a1382:	b130      	cbz	r0, 80a1392 <pinAvailable+0x3a>
 80a1384:	f1a4 0012 	sub.w	r0, r4, #18
 80a1388:	2801      	cmp	r0, #1
 80a138a:	bf94      	ite	ls
 80a138c:	2000      	movls	r0, #0
 80a138e:	2001      	movhi	r0, #1
 80a1390:	bd10      	pop	{r4, pc}
  {
    return 0; // 'pin' is used
  }
#endif
  return 1; // 'pin' is available
 80a1392:	2001      	movs	r0, #1
}
 80a1394:	bd10      	pop	{r4, pc}
 80a1396:	bf00      	nop
 80a1398:	200004b0 	.word	0x200004b0
 80a139c:	20000484 	.word	0x20000484
 80a13a0:	200003d4 	.word	0x200003d4

080a13a4 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a13a4:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a13a6:	b538      	push	{r3, r4, r5, lr}
 80a13a8:	4605      	mov	r5, r0
 80a13aa:	460c      	mov	r4, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a13ac:	d80a      	bhi.n	80a13c4 <pinMode+0x20>
 80a13ae:	29ff      	cmp	r1, #255	; 0xff
 80a13b0:	d008      	beq.n	80a13c4 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a13b2:	f7ff ffd1 	bl	80a1358 <pinAvailable>
 80a13b6:	b128      	cbz	r0, 80a13c4 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a13b8:	4628      	mov	r0, r5
 80a13ba:	4621      	mov	r1, r4
}
 80a13bc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a13c0:	f7ff bae8 	b.w	80a0994 <HAL_Pin_Mode>
 80a13c4:	bd38      	pop	{r3, r4, r5, pc}

080a13c6 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a13c6:	b538      	push	{r3, r4, r5, lr}
 80a13c8:	4604      	mov	r4, r0
 80a13ca:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a13cc:	f7ff faea 	bl	80a09a4 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a13d0:	28ff      	cmp	r0, #255	; 0xff
 80a13d2:	d010      	beq.n	80a13f6 <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a13d4:	b178      	cbz	r0, 80a13f6 <digitalWrite+0x30>
#endif
  return 1; // 'pin' is available
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
 80a13d6:	1e83      	subs	r3, r0, #2
 80a13d8:	b2db      	uxtb	r3, r3
 80a13da:	2b01      	cmp	r3, #1
 80a13dc:	d90b      	bls.n	80a13f6 <digitalWrite+0x30>
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a13de:	2806      	cmp	r0, #6
 80a13e0:	d009      	beq.n	80a13f6 <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a13e2:	4620      	mov	r0, r4
 80a13e4:	f7ff ffb8 	bl	80a1358 <pinAvailable>
 80a13e8:	b128      	cbz	r0, 80a13f6 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a13ea:	4620      	mov	r0, r4
 80a13ec:	4629      	mov	r1, r5
}
 80a13ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a13f2:	f7ff badf 	b.w	80a09b4 <HAL_GPIO_Write>
 80a13f6:	bd38      	pop	{r3, r4, r5, pc}

080a13f8 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a13f8:	b510      	push	{r4, lr}
 80a13fa:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a13fc:	f7ff fad2 	bl	80a09a4 <HAL_Get_Pin_Mode>

  HAL_GPIO_Write(pin, value);
}

inline bool is_af_output_mode(PinMode mode) {
    return mode == AF_OUTPUT_PUSHPULL ||
 80a1400:	3804      	subs	r0, #4
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (is_af_output_mode(mode))
 80a1402:	b2c0      	uxtb	r0, r0
 80a1404:	2801      	cmp	r0, #1
 80a1406:	d908      	bls.n	80a141a <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a1408:	4620      	mov	r0, r4
 80a140a:	f7ff ffa5 	bl	80a1358 <pinAvailable>
 80a140e:	b120      	cbz	r0, 80a141a <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a1410:	4620      	mov	r0, r4
}
 80a1412:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // Safety check
    if( !pinAvailable(pin) ) {
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a1416:	f7ff bad5 	b.w	80a09c4 <HAL_GPIO_Read>
}
 80a141a:	2000      	movs	r0, #0
 80a141c:	bd10      	pop	{r4, pc}

080a141e <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a141e:	b510      	push	{r4, lr}
 80a1420:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a1422:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a1424:	bf9c      	itt	ls
 80a1426:	340a      	addls	r4, #10
 80a1428:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a142a:	4620      	mov	r0, r4
 80a142c:	f7ff ff94 	bl	80a1358 <pinAvailable>
 80a1430:	b150      	cbz	r0, 80a1448 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a1432:	4620      	mov	r0, r4
 80a1434:	2103      	movs	r1, #3
 80a1436:	f7ff faa5 	bl	80a0984 <HAL_Validate_Pin_Function>
 80a143a:	2803      	cmp	r0, #3
 80a143c:	d104      	bne.n	80a1448 <analogRead+0x2a>
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a143e:	4620      	mov	r0, r4
}
 80a1440:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a1444:	f7ff bad6 	b.w	80a09f4 <HAL_ADC_Read>
}
 80a1448:	2000      	movs	r0, #0
 80a144a:	bd10      	pop	{r4, pc}

080a144c <analogWrite>:
/*
 * @brief Should take an integer 0-255 and create a 500Hz PWM signal with a duty cycle from 0-100%.
 * On Photon, DAC1 and DAC2 act as true analog outputs(values: 0 to 4095) using onchip DAC peripheral
 */
void analogWrite(pin_t pin, uint16_t value)
{
 80a144c:	b538      	push	{r3, r4, r5, lr}
 80a144e:	4604      	mov	r4, r0
 80a1450:	460d      	mov	r5, r1
    // Safety check
    if (!pinAvailable(pin))
 80a1452:	f7ff ff81 	bl	80a1358 <pinAvailable>
 80a1456:	b1e8      	cbz	r0, 80a1494 <analogWrite+0x48>
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a1458:	4620      	mov	r0, r4
 80a145a:	2104      	movs	r1, #4
 80a145c:	f7ff fa92 	bl	80a0984 <HAL_Validate_Pin_Function>
 80a1460:	2804      	cmp	r0, #4
    {
        HAL_DAC_Write(pin, value);
 80a1462:	4620      	mov	r0, r4
    if (!pinAvailable(pin))
    {
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
 80a1464:	d104      	bne.n	80a1470 <analogWrite+0x24>
    {
        HAL_DAC_Write(pin, value);
 80a1466:	4629      	mov	r1, r5
            return;
        }

        HAL_PWM_Write(pin, value);
    }
}
 80a1468:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        return;
    }

    if (HAL_Validate_Pin_Function(pin, PF_DAC) == PF_DAC)
    {
        HAL_DAC_Write(pin, value);
 80a146c:	f7ff baba 	b.w	80a09e4 <HAL_DAC_Write>
    }
    else if (HAL_Validate_Pin_Function(pin, PF_TIMER) == PF_TIMER)
 80a1470:	2102      	movs	r1, #2
 80a1472:	f7ff fa87 	bl	80a0984 <HAL_Validate_Pin_Function>
 80a1476:	2802      	cmp	r0, #2
 80a1478:	d10c      	bne.n	80a1494 <analogWrite+0x48>
    {
        PinMode mode = HAL_Get_Pin_Mode(pin);
 80a147a:	4620      	mov	r0, r4
 80a147c:	f7ff fa92 	bl	80a09a4 <HAL_Get_Pin_Mode>

        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
 80a1480:	2801      	cmp	r0, #1
 80a1482:	d001      	beq.n	80a1488 <analogWrite+0x3c>
 80a1484:	2804      	cmp	r0, #4
 80a1486:	d105      	bne.n	80a1494 <analogWrite+0x48>
        {
            return;
        }

        HAL_PWM_Write(pin, value);
 80a1488:	4620      	mov	r0, r4
 80a148a:	b2e9      	uxtb	r1, r5
    }
}
 80a148c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        if (mode != OUTPUT && mode != AF_OUTPUT_PUSHPULL)
        {
            return;
        }

        HAL_PWM_Write(pin, value);
 80a1490:	f7ff bab8 	b.w	80a0a04 <HAL_PWM_Write>
 80a1494:	bd38      	pop	{r3, r4, r5, pc}
	...

080a1498 <_GLOBAL__sub_I_EEPROM>:
// we don't use this global instance since there's no actual instance data
// Having this keeps the unoptimized build happy


EEPROMClass EEPROM;
EEPROMInitClass EEPROMInit;
 80a1498:	4801      	ldr	r0, [pc, #4]	; (80a14a0 <_GLOBAL__sub_I_EEPROM+0x8>)
 80a149a:	f7ff bc1a 	b.w	80a0cd2 <_ZN15EEPROMInitClassC1Ev>
 80a149e:	bf00      	nop
 80a14a0:	20000480 	.word	0x20000480

080a14a4 <_GLOBAL__sub_I_Wire>:
#include "spark_wiring_i2c.h"
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire Wire(HAL_I2C_INTERFACE1);
 80a14a4:	b510      	push	{r4, lr}
 80a14a6:	4c06      	ldr	r4, [pc, #24]	; (80a14c0 <_GLOBAL__sub_I_Wire+0x1c>)
 80a14a8:	2100      	movs	r1, #0
 80a14aa:	4620      	mov	r0, r4
 80a14ac:	f7ff fc44 	bl	80a0d38 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a14b0:	4620      	mov	r0, r4
 80a14b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a14b6:	4903      	ldr	r1, [pc, #12]	; (80a14c4 <_GLOBAL__sub_I_Wire+0x20>)
 80a14b8:	4a03      	ldr	r2, [pc, #12]	; (80a14c8 <_GLOBAL__sub_I_Wire+0x24>)
 80a14ba:	f000 b841 	b.w	80a1540 <__aeabi_atexit>
 80a14be:	bf00      	nop
 80a14c0:	20000484 	.word	0x20000484
 80a14c4:	080a0ce3 	.word	0x080a0ce3
 80a14c8:	2000036c 	.word	0x2000036c

080a14cc <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a14cc:	b513      	push	{r0, r1, r4, lr}
 80a14ce:	4c08      	ldr	r4, [pc, #32]	; (80a14f0 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a14d0:	2100      	movs	r1, #0
 80a14d2:	9100      	str	r1, [sp, #0]
 80a14d4:	460a      	mov	r2, r1
 80a14d6:	460b      	mov	r3, r1
 80a14d8:	4620      	mov	r0, r4
 80a14da:	f7ff fc73 	bl	80a0dc4 <_ZN9IPAddressC1Ehhhh>
 80a14de:	4620      	mov	r0, r4
 80a14e0:	4904      	ldr	r1, [pc, #16]	; (80a14f4 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a14e2:	4a05      	ldr	r2, [pc, #20]	; (80a14f8 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a14e4:	b002      	add	sp, #8
 80a14e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a14ea:	f000 b829 	b.w	80a1540 <__aeabi_atexit>
 80a14ee:	bf00      	nop
 80a14f0:	20000498 	.word	0x20000498
 80a14f4:	080a0d69 	.word	0x080a0d69
 80a14f8:	2000036c 	.word	0x2000036c

080a14fc <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a14fc:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a14fe:	4e0c      	ldr	r6, [pc, #48]	; (80a1530 <_GLOBAL__sub_I_SPI+0x34>)
 80a1500:	4d0c      	ldr	r5, [pc, #48]	; (80a1534 <_GLOBAL__sub_I_SPI+0x38>)
 80a1502:	4c0d      	ldr	r4, [pc, #52]	; (80a1538 <_GLOBAL__sub_I_SPI+0x3c>)
 80a1504:	4630      	mov	r0, r6
 80a1506:	2100      	movs	r1, #0
 80a1508:	f7ff fd5a 	bl	80a0fc0 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a150c:	4630      	mov	r0, r6

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a150e:	4e0b      	ldr	r6, [pc, #44]	; (80a153c <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1510:	4622      	mov	r2, r4
 80a1512:	4629      	mov	r1, r5
 80a1514:	f000 f814 	bl	80a1540 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1518:	4630      	mov	r0, r6
 80a151a:	2101      	movs	r1, #1
 80a151c:	f7ff fd50 	bl	80a0fc0 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a1520:	4630      	mov	r0, r6
 80a1522:	4629      	mov	r1, r5
 80a1524:	4622      	mov	r2, r4
 80a1526:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a152a:	f000 b809 	b.w	80a1540 <__aeabi_atexit>
 80a152e:	bf00      	nop
 80a1530:	200004b0 	.word	0x200004b0
 80a1534:	080a0fb3 	.word	0x080a0fb3
 80a1538:	2000036c 	.word	0x2000036c
 80a153c:	200004bc 	.word	0x200004bc

080a1540 <__aeabi_atexit>:
 80a1540:	4603      	mov	r3, r0
 80a1542:	4608      	mov	r0, r1
 80a1544:	4619      	mov	r1, r3
 80a1546:	f000 b8cd 	b.w	80a16e4 <__cxa_atexit>
	...

080a154c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE>:
 80a154c:	4b24      	ldr	r3, [pc, #144]	; (80a15e0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x94>)
 80a154e:	681a      	ldr	r2, [r3, #0]
 80a1550:	07d0      	lsls	r0, r2, #31
 80a1552:	bf5c      	itt	pl
 80a1554:	2201      	movpl	r2, #1
 80a1556:	601a      	strpl	r2, [r3, #0]
 80a1558:	4b22      	ldr	r3, [pc, #136]	; (80a15e4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x98>)
 80a155a:	681a      	ldr	r2, [r3, #0]
 80a155c:	07d1      	lsls	r1, r2, #31
 80a155e:	bf5c      	itt	pl
 80a1560:	2201      	movpl	r2, #1
 80a1562:	601a      	strpl	r2, [r3, #0]
 80a1564:	4b20      	ldr	r3, [pc, #128]	; (80a15e8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x9c>)
 80a1566:	681a      	ldr	r2, [r3, #0]
 80a1568:	07d2      	lsls	r2, r2, #31
 80a156a:	bf5c      	itt	pl
 80a156c:	2201      	movpl	r2, #1
 80a156e:	601a      	strpl	r2, [r3, #0]
 80a1570:	4b1e      	ldr	r3, [pc, #120]	; (80a15ec <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa0>)
 80a1572:	681a      	ldr	r2, [r3, #0]
 80a1574:	07d0      	lsls	r0, r2, #31
 80a1576:	bf5c      	itt	pl
 80a1578:	2201      	movpl	r2, #1
 80a157a:	601a      	strpl	r2, [r3, #0]
 80a157c:	4b1c      	ldr	r3, [pc, #112]	; (80a15f0 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa4>)
 80a157e:	681a      	ldr	r2, [r3, #0]
 80a1580:	07d1      	lsls	r1, r2, #31
 80a1582:	bf5c      	itt	pl
 80a1584:	2201      	movpl	r2, #1
 80a1586:	601a      	strpl	r2, [r3, #0]
 80a1588:	4b1a      	ldr	r3, [pc, #104]	; (80a15f4 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa8>)
 80a158a:	681a      	ldr	r2, [r3, #0]
 80a158c:	07d2      	lsls	r2, r2, #31
 80a158e:	bf5c      	itt	pl
 80a1590:	2201      	movpl	r2, #1
 80a1592:	601a      	strpl	r2, [r3, #0]
 80a1594:	4b18      	ldr	r3, [pc, #96]	; (80a15f8 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xac>)
 80a1596:	681a      	ldr	r2, [r3, #0]
 80a1598:	07d0      	lsls	r0, r2, #31
 80a159a:	bf5c      	itt	pl
 80a159c:	2201      	movpl	r2, #1
 80a159e:	601a      	strpl	r2, [r3, #0]
 80a15a0:	4b16      	ldr	r3, [pc, #88]	; (80a15fc <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb0>)
 80a15a2:	681a      	ldr	r2, [r3, #0]
 80a15a4:	07d1      	lsls	r1, r2, #31
 80a15a6:	bf5c      	itt	pl
 80a15a8:	2201      	movpl	r2, #1
 80a15aa:	601a      	strpl	r2, [r3, #0]
 80a15ac:	4b14      	ldr	r3, [pc, #80]	; (80a1600 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb4>)
 80a15ae:	681a      	ldr	r2, [r3, #0]
 80a15b0:	07d2      	lsls	r2, r2, #31
 80a15b2:	bf5c      	itt	pl
 80a15b4:	2201      	movpl	r2, #1
 80a15b6:	601a      	strpl	r2, [r3, #0]
 80a15b8:	4b12      	ldr	r3, [pc, #72]	; (80a1604 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb8>)
 80a15ba:	681a      	ldr	r2, [r3, #0]
 80a15bc:	07d0      	lsls	r0, r2, #31
 80a15be:	bf5c      	itt	pl
 80a15c0:	2201      	movpl	r2, #1
 80a15c2:	601a      	strpl	r2, [r3, #0]
 80a15c4:	4b10      	ldr	r3, [pc, #64]	; (80a1608 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xbc>)
 80a15c6:	681a      	ldr	r2, [r3, #0]
 80a15c8:	07d1      	lsls	r1, r2, #31
 80a15ca:	bf5c      	itt	pl
 80a15cc:	2201      	movpl	r2, #1
 80a15ce:	601a      	strpl	r2, [r3, #0]
 80a15d0:	4b0e      	ldr	r3, [pc, #56]	; (80a160c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc0>)
 80a15d2:	681a      	ldr	r2, [r3, #0]
 80a15d4:	07d2      	lsls	r2, r2, #31
 80a15d6:	bf5c      	itt	pl
 80a15d8:	2201      	movpl	r2, #1
 80a15da:	601a      	strpl	r2, [r3, #0]
 80a15dc:	4770      	bx	lr
 80a15de:	bf00      	nop
 80a15e0:	200004f4 	.word	0x200004f4
 80a15e4:	200004f0 	.word	0x200004f0
 80a15e8:	200004ec 	.word	0x200004ec
 80a15ec:	200004e8 	.word	0x200004e8
 80a15f0:	200004e4 	.word	0x200004e4
 80a15f4:	200004e0 	.word	0x200004e0
 80a15f8:	200004dc 	.word	0x200004dc
 80a15fc:	200004d8 	.word	0x200004d8
 80a1600:	200004d4 	.word	0x200004d4
 80a1604:	200004d0 	.word	0x200004d0
 80a1608:	200004cc 	.word	0x200004cc
 80a160c:	200004c8 	.word	0x200004c8

080a1610 <_ZSt25__throw_bad_function_callv>:
 80a1610:	b508      	push	{r3, lr}
 80a1612:	f7ff fb11 	bl	80a0c38 <abort>
	...

080a1618 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE>:
 80a1618:	4b24      	ldr	r3, [pc, #144]	; (80a16ac <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x94>)
 80a161a:	681a      	ldr	r2, [r3, #0]
 80a161c:	07d0      	lsls	r0, r2, #31
 80a161e:	bf5c      	itt	pl
 80a1620:	2201      	movpl	r2, #1
 80a1622:	601a      	strpl	r2, [r3, #0]
 80a1624:	4b22      	ldr	r3, [pc, #136]	; (80a16b0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x98>)
 80a1626:	681a      	ldr	r2, [r3, #0]
 80a1628:	07d1      	lsls	r1, r2, #31
 80a162a:	bf5c      	itt	pl
 80a162c:	2201      	movpl	r2, #1
 80a162e:	601a      	strpl	r2, [r3, #0]
 80a1630:	4b20      	ldr	r3, [pc, #128]	; (80a16b4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x9c>)
 80a1632:	681a      	ldr	r2, [r3, #0]
 80a1634:	07d2      	lsls	r2, r2, #31
 80a1636:	bf5c      	itt	pl
 80a1638:	2201      	movpl	r2, #1
 80a163a:	601a      	strpl	r2, [r3, #0]
 80a163c:	4b1e      	ldr	r3, [pc, #120]	; (80a16b8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa0>)
 80a163e:	681a      	ldr	r2, [r3, #0]
 80a1640:	07d0      	lsls	r0, r2, #31
 80a1642:	bf5c      	itt	pl
 80a1644:	2201      	movpl	r2, #1
 80a1646:	601a      	strpl	r2, [r3, #0]
 80a1648:	4b1c      	ldr	r3, [pc, #112]	; (80a16bc <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa4>)
 80a164a:	681a      	ldr	r2, [r3, #0]
 80a164c:	07d1      	lsls	r1, r2, #31
 80a164e:	bf5c      	itt	pl
 80a1650:	2201      	movpl	r2, #1
 80a1652:	601a      	strpl	r2, [r3, #0]
 80a1654:	4b1a      	ldr	r3, [pc, #104]	; (80a16c0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa8>)
 80a1656:	681a      	ldr	r2, [r3, #0]
 80a1658:	07d2      	lsls	r2, r2, #31
 80a165a:	bf5c      	itt	pl
 80a165c:	2201      	movpl	r2, #1
 80a165e:	601a      	strpl	r2, [r3, #0]
 80a1660:	4b18      	ldr	r3, [pc, #96]	; (80a16c4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xac>)
 80a1662:	681a      	ldr	r2, [r3, #0]
 80a1664:	07d0      	lsls	r0, r2, #31
 80a1666:	bf5c      	itt	pl
 80a1668:	2201      	movpl	r2, #1
 80a166a:	601a      	strpl	r2, [r3, #0]
 80a166c:	4b16      	ldr	r3, [pc, #88]	; (80a16c8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb0>)
 80a166e:	681a      	ldr	r2, [r3, #0]
 80a1670:	07d1      	lsls	r1, r2, #31
 80a1672:	bf5c      	itt	pl
 80a1674:	2201      	movpl	r2, #1
 80a1676:	601a      	strpl	r2, [r3, #0]
 80a1678:	4b14      	ldr	r3, [pc, #80]	; (80a16cc <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb4>)
 80a167a:	681a      	ldr	r2, [r3, #0]
 80a167c:	07d2      	lsls	r2, r2, #31
 80a167e:	bf5c      	itt	pl
 80a1680:	2201      	movpl	r2, #1
 80a1682:	601a      	strpl	r2, [r3, #0]
 80a1684:	4b12      	ldr	r3, [pc, #72]	; (80a16d0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb8>)
 80a1686:	681a      	ldr	r2, [r3, #0]
 80a1688:	07d0      	lsls	r0, r2, #31
 80a168a:	bf5c      	itt	pl
 80a168c:	2201      	movpl	r2, #1
 80a168e:	601a      	strpl	r2, [r3, #0]
 80a1690:	4b10      	ldr	r3, [pc, #64]	; (80a16d4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xbc>)
 80a1692:	681a      	ldr	r2, [r3, #0]
 80a1694:	07d1      	lsls	r1, r2, #31
 80a1696:	bf5c      	itt	pl
 80a1698:	2201      	movpl	r2, #1
 80a169a:	601a      	strpl	r2, [r3, #0]
 80a169c:	4b0e      	ldr	r3, [pc, #56]	; (80a16d8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc0>)
 80a169e:	681a      	ldr	r2, [r3, #0]
 80a16a0:	07d2      	lsls	r2, r2, #31
 80a16a2:	bf5c      	itt	pl
 80a16a4:	2201      	movpl	r2, #1
 80a16a6:	601a      	strpl	r2, [r3, #0]
 80a16a8:	4770      	bx	lr
 80a16aa:	bf00      	nop
 80a16ac:	20000524 	.word	0x20000524
 80a16b0:	20000520 	.word	0x20000520
 80a16b4:	2000051c 	.word	0x2000051c
 80a16b8:	20000518 	.word	0x20000518
 80a16bc:	20000514 	.word	0x20000514
 80a16c0:	20000510 	.word	0x20000510
 80a16c4:	2000050c 	.word	0x2000050c
 80a16c8:	20000508 	.word	0x20000508
 80a16cc:	20000504 	.word	0x20000504
 80a16d0:	20000500 	.word	0x20000500
 80a16d4:	200004fc 	.word	0x200004fc
 80a16d8:	200004f8 	.word	0x200004f8

080a16dc <atol>:
 80a16dc:	2100      	movs	r1, #0
 80a16de:	220a      	movs	r2, #10
 80a16e0:	f000 b8d6 	b.w	80a1890 <strtol>

080a16e4 <__cxa_atexit>:
 80a16e4:	b538      	push	{r3, r4, r5, lr}
 80a16e6:	4605      	mov	r5, r0
 80a16e8:	4804      	ldr	r0, [pc, #16]	; (80a16fc <__cxa_atexit+0x18>)
 80a16ea:	460c      	mov	r4, r1
 80a16ec:	4613      	mov	r3, r2
 80a16ee:	b120      	cbz	r0, 80a16fa <__cxa_atexit+0x16>
 80a16f0:	2002      	movs	r0, #2
 80a16f2:	4629      	mov	r1, r5
 80a16f4:	4622      	mov	r2, r4
 80a16f6:	f3af 8000 	nop.w
 80a16fa:	bd38      	pop	{r3, r4, r5, pc}
 80a16fc:	00000000 	.word	0x00000000

080a1700 <ldiv>:
 80a1700:	b510      	push	{r4, lr}
 80a1702:	fb91 f4f2 	sdiv	r4, r1, r2
 80a1706:	2900      	cmp	r1, #0
 80a1708:	fb02 1314 	mls	r3, r2, r4, r1
 80a170c:	db04      	blt.n	80a1718 <ldiv+0x18>
 80a170e:	2b00      	cmp	r3, #0
 80a1710:	da07      	bge.n	80a1722 <ldiv+0x22>
 80a1712:	3401      	adds	r4, #1
 80a1714:	1a9b      	subs	r3, r3, r2
 80a1716:	e004      	b.n	80a1722 <ldiv+0x22>
 80a1718:	2b00      	cmp	r3, #0
 80a171a:	bfc4      	itt	gt
 80a171c:	f104 34ff 	addgt.w	r4, r4, #4294967295	; 0xffffffff
 80a1720:	189b      	addgt	r3, r3, r2
 80a1722:	6004      	str	r4, [r0, #0]
 80a1724:	6043      	str	r3, [r0, #4]
 80a1726:	bd10      	pop	{r4, pc}

080a1728 <memcpy>:
 80a1728:	b510      	push	{r4, lr}
 80a172a:	1e43      	subs	r3, r0, #1
 80a172c:	440a      	add	r2, r1
 80a172e:	4291      	cmp	r1, r2
 80a1730:	d004      	beq.n	80a173c <memcpy+0x14>
 80a1732:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a1736:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a173a:	e7f8      	b.n	80a172e <memcpy+0x6>
 80a173c:	bd10      	pop	{r4, pc}

080a173e <memset>:
 80a173e:	4603      	mov	r3, r0
 80a1740:	4402      	add	r2, r0
 80a1742:	4293      	cmp	r3, r2
 80a1744:	d002      	beq.n	80a174c <memset+0xe>
 80a1746:	f803 1b01 	strb.w	r1, [r3], #1
 80a174a:	e7fa      	b.n	80a1742 <memset+0x4>
 80a174c:	4770      	bx	lr

080a174e <strcmp>:
 80a174e:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a1752:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a1756:	2a01      	cmp	r2, #1
 80a1758:	bf28      	it	cs
 80a175a:	429a      	cmpcs	r2, r3
 80a175c:	d0f7      	beq.n	80a174e <strcmp>
 80a175e:	1ad0      	subs	r0, r2, r3
 80a1760:	4770      	bx	lr

080a1762 <strcpy>:
 80a1762:	4603      	mov	r3, r0
 80a1764:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a1768:	f803 2b01 	strb.w	r2, [r3], #1
 80a176c:	2a00      	cmp	r2, #0
 80a176e:	d1f9      	bne.n	80a1764 <strcpy+0x2>
 80a1770:	4770      	bx	lr

080a1772 <strlen>:
 80a1772:	4603      	mov	r3, r0
 80a1774:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a1778:	2a00      	cmp	r2, #0
 80a177a:	d1fb      	bne.n	80a1774 <strlen+0x2>
 80a177c:	1a18      	subs	r0, r3, r0
 80a177e:	3801      	subs	r0, #1
 80a1780:	4770      	bx	lr
	...

080a1784 <_strtol_r>:
 80a1784:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a1788:	460f      	mov	r7, r1
 80a178a:	4c40      	ldr	r4, [pc, #256]	; (80a188c <_strtol_r+0x108>)
 80a178c:	f8d4 9000 	ldr.w	r9, [r4]
 80a1790:	463d      	mov	r5, r7
 80a1792:	f815 eb01 	ldrb.w	lr, [r5], #1
 80a1796:	eb09 040e 	add.w	r4, r9, lr
 80a179a:	7866      	ldrb	r6, [r4, #1]
 80a179c:	f006 0408 	and.w	r4, r6, #8
 80a17a0:	f004 06ff 	and.w	r6, r4, #255	; 0xff
 80a17a4:	b10c      	cbz	r4, 80a17aa <_strtol_r+0x26>
 80a17a6:	462f      	mov	r7, r5
 80a17a8:	e7f2      	b.n	80a1790 <_strtol_r+0xc>
 80a17aa:	4674      	mov	r4, lr
 80a17ac:	2c2d      	cmp	r4, #45	; 0x2d
 80a17ae:	d103      	bne.n	80a17b8 <_strtol_r+0x34>
 80a17b0:	1cbd      	adds	r5, r7, #2
 80a17b2:	787c      	ldrb	r4, [r7, #1]
 80a17b4:	2601      	movs	r6, #1
 80a17b6:	e003      	b.n	80a17c0 <_strtol_r+0x3c>
 80a17b8:	2c2b      	cmp	r4, #43	; 0x2b
 80a17ba:	bf04      	itt	eq
 80a17bc:	787c      	ldrbeq	r4, [r7, #1]
 80a17be:	1cbd      	addeq	r5, r7, #2
 80a17c0:	b113      	cbz	r3, 80a17c8 <_strtol_r+0x44>
 80a17c2:	2b10      	cmp	r3, #16
 80a17c4:	d10a      	bne.n	80a17dc <_strtol_r+0x58>
 80a17c6:	e05a      	b.n	80a187e <_strtol_r+0xfa>
 80a17c8:	2c30      	cmp	r4, #48	; 0x30
 80a17ca:	d156      	bne.n	80a187a <_strtol_r+0xf6>
 80a17cc:	782c      	ldrb	r4, [r5, #0]
 80a17ce:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 80a17d2:	2c58      	cmp	r4, #88	; 0x58
 80a17d4:	d14c      	bne.n	80a1870 <_strtol_r+0xec>
 80a17d6:	786c      	ldrb	r4, [r5, #1]
 80a17d8:	2310      	movs	r3, #16
 80a17da:	3502      	adds	r5, #2
 80a17dc:	2e00      	cmp	r6, #0
 80a17de:	bf14      	ite	ne
 80a17e0:	f04f 4800 	movne.w	r8, #2147483648	; 0x80000000
 80a17e4:	f06f 4800 	mvneq.w	r8, #2147483648	; 0x80000000
 80a17e8:	fbb8 faf3 	udiv	sl, r8, r3
 80a17ec:	2700      	movs	r7, #0
 80a17ee:	46be      	mov	lr, r7
 80a17f0:	fb03 881a 	mls	r8, r3, sl, r8
 80a17f4:	eb09 0c04 	add.w	ip, r9, r4
 80a17f8:	f89c c001 	ldrb.w	ip, [ip, #1]
 80a17fc:	f01c 0f04 	tst.w	ip, #4
 80a1800:	d001      	beq.n	80a1806 <_strtol_r+0x82>
 80a1802:	3c30      	subs	r4, #48	; 0x30
 80a1804:	e00b      	b.n	80a181e <_strtol_r+0x9a>
 80a1806:	f01c 0c03 	ands.w	ip, ip, #3
 80a180a:	d01b      	beq.n	80a1844 <_strtol_r+0xc0>
 80a180c:	f1bc 0f01 	cmp.w	ip, #1
 80a1810:	bf0c      	ite	eq
 80a1812:	f04f 0c37 	moveq.w	ip, #55	; 0x37
 80a1816:	f04f 0c57 	movne.w	ip, #87	; 0x57
 80a181a:	ebcc 0404 	rsb	r4, ip, r4
 80a181e:	429c      	cmp	r4, r3
 80a1820:	da10      	bge.n	80a1844 <_strtol_r+0xc0>
 80a1822:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
 80a1826:	d00a      	beq.n	80a183e <_strtol_r+0xba>
 80a1828:	45d6      	cmp	lr, sl
 80a182a:	d806      	bhi.n	80a183a <_strtol_r+0xb6>
 80a182c:	d101      	bne.n	80a1832 <_strtol_r+0xae>
 80a182e:	4544      	cmp	r4, r8
 80a1830:	dc03      	bgt.n	80a183a <_strtol_r+0xb6>
 80a1832:	fb03 4e0e 	mla	lr, r3, lr, r4
 80a1836:	2701      	movs	r7, #1
 80a1838:	e001      	b.n	80a183e <_strtol_r+0xba>
 80a183a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a183e:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a1842:	e7d7      	b.n	80a17f4 <_strtol_r+0x70>
 80a1844:	1c7c      	adds	r4, r7, #1
 80a1846:	4673      	mov	r3, lr
 80a1848:	d10a      	bne.n	80a1860 <_strtol_r+0xdc>
 80a184a:	2e00      	cmp	r6, #0
 80a184c:	f04f 0122 	mov.w	r1, #34	; 0x22
 80a1850:	bf14      	ite	ne
 80a1852:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
 80a1856:	f06f 4300 	mvneq.w	r3, #2147483648	; 0x80000000
 80a185a:	6001      	str	r1, [r0, #0]
 80a185c:	b92a      	cbnz	r2, 80a186a <_strtol_r+0xe6>
 80a185e:	e011      	b.n	80a1884 <_strtol_r+0x100>
 80a1860:	b10e      	cbz	r6, 80a1866 <_strtol_r+0xe2>
 80a1862:	f1ce 0300 	rsb	r3, lr, #0
 80a1866:	b16a      	cbz	r2, 80a1884 <_strtol_r+0x100>
 80a1868:	b107      	cbz	r7, 80a186c <_strtol_r+0xe8>
 80a186a:	1e69      	subs	r1, r5, #1
 80a186c:	6011      	str	r1, [r2, #0]
 80a186e:	e009      	b.n	80a1884 <_strtol_r+0x100>
 80a1870:	2430      	movs	r4, #48	; 0x30
 80a1872:	2b00      	cmp	r3, #0
 80a1874:	d1b2      	bne.n	80a17dc <_strtol_r+0x58>
 80a1876:	2308      	movs	r3, #8
 80a1878:	e7b0      	b.n	80a17dc <_strtol_r+0x58>
 80a187a:	230a      	movs	r3, #10
 80a187c:	e7ae      	b.n	80a17dc <_strtol_r+0x58>
 80a187e:	2c30      	cmp	r4, #48	; 0x30
 80a1880:	d1ac      	bne.n	80a17dc <_strtol_r+0x58>
 80a1882:	e7a3      	b.n	80a17cc <_strtol_r+0x48>
 80a1884:	4618      	mov	r0, r3
 80a1886:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a188a:	bf00      	nop
 80a188c:	20000304 	.word	0x20000304

080a1890 <strtol>:
 80a1890:	b530      	push	{r4, r5, lr}
 80a1892:	4605      	mov	r5, r0
 80a1894:	460c      	mov	r4, r1
 80a1896:	4613      	mov	r3, r2
 80a1898:	4a03      	ldr	r2, [pc, #12]	; (80a18a8 <strtol+0x18>)
 80a189a:	4629      	mov	r1, r5
 80a189c:	6810      	ldr	r0, [r2, #0]
 80a189e:	4622      	mov	r2, r4
 80a18a0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80a18a4:	f7ff bf6e 	b.w	80a1784 <_strtol_r>
 80a18a8:	20000368 	.word	0x20000368

080a18ac <dynalib_user>:
 80a18ac:	080a0045 080a001d 080a0085 080a0089     E...............
 80a18bc:	00000000 67676f74 6557656c 73006f6d     ....toggleWemo.s
 80a18cc:	53636e79 6f767265 47520073 75420042     yncServos.RGB.Bu
 80a18dc:	6e6f7474 65727020 64657373 4f4e0021     tton pressed!.NO
 80a18ec:	21455349 69724f00 616e6967 7453206c     ISE!.Original St
 80a18fc:	676e6972 4552003a 47003a44 4e454552     ring:.RED:.GREEN
 80a190c:	4c42003a 003a4555 00646572 65756c62     :.BLUE:.red.blue
 80a191c:	65726700 32006e65 4f003030 69676972     .green.200.Origi
 80a192c:	206c616e 69727453 203a676e 63654e00     nal String: .Nec
 80a193c:	00203a6b 68676952 00203a74 7466654c     k: .Right: .Left
 80a194c:	6e00203a 006b6365 68676972 6d724174     : .neck.rightArm
 80a195c:	66656c00 6d724174 69726200 6e746867     .leftArm.brightn
 80a196c:	00737365 73696f6e 6f6d0065 65536576     ess.noise.moveSe
 80a197c:	736f7672 6f6f6d00 67696c64 00737468     rvos.moodlights.
 80a198c:	62616e65 6c53656c 00657661              enableSlave.

080a1998 <_ZTV7TwoWire>:
	...
 80a19a0:	080a0ce3 080a0d2d 080a0d05 080a0ce5     ....-...........
 80a19b0:	080a0d0d 080a0d15 080a0d1d 080a0d25     ............%...

080a19c0 <_ZTV9IPAddress>:
	...
 80a19c8:	080a0d77 080a0d69 080a0d6b 00000000     w...i...k.......

080a19d8 <_ZTV8SPIClass>:
	...
 80a19e0:	080a0fb3 080a0fb5 2b25005a 3a643330     ........Z.%+03d:
 80a19f0:	75323025 2d592500 252d6d25 48255464     %02u.%Y-%m-%dT%H
 80a1a00:	3a4d253a 7a255325 63736100 656d6974     :%M:%S%z.asctime
	...

080a1a18 <_ZTV11USARTSerial>:
	...
 80a1a20:	080a11b1 080a11d1 080a11cb 080a0de1     ................
 80a1a30:	080a11b3 080a11bf 080a11b9 080a11c5     ................

080a1a40 <_ZTV9USBSerial>:
	...
 80a1a48:	080a1243 080a1265 080a1259 080a0de1     C...e...Y.......
 80a1a58:	080a1251 080a1245 080a124b 080a1241     Q...E...K...A...

080a1a68 <_ZTVN5spark9WiFiClassE>:
	...
 80a1a70:	080a12b3 00000000                       ........

080a1a78 <_ctype_>:
 80a1a78:	20202000 20202020 28282020 20282828     .         ((((( 
 80a1a88:	20202020 20202020 20202020 20202020                     
 80a1a98:	10108820 10101010 10101010 10101010      ...............
 80a1aa8:	04040410 04040404 10040404 10101010     ................
 80a1ab8:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a1ac8:	01010101 01010101 01010101 10101010     ................
 80a1ad8:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a1ae8:	02020202 02020202 02020202 10101010     ................
 80a1af8:	00000020 00000000 00000000 00000000      ...............
	...
 80a1b78:	00004300                                         .C.

080a1b7b <link_const_variable_data_end>:
	...

080a1b7c <link_constructors_location>:
 80a1b7c:	080a01a9 	.word	0x080a01a9
 80a1b80:	080a0925 	.word	0x080a0925
 80a1b84:	080a1197 	.word	0x080a1197
 80a1b88:	080a119d 	.word	0x080a119d
 80a1b8c:	080a120d 	.word	0x080a120d
 80a1b90:	080a128d 	.word	0x080a128d
 80a1b94:	080a12bd 	.word	0x080a12bd
 80a1b98:	080a1499 	.word	0x080a1499
 80a1b9c:	080a14a5 	.word	0x080a14a5
 80a1ba0:	080a14cd 	.word	0x080a14cd
 80a1ba4:	080a14fd 	.word	0x080a14fd
 80a1ba8:	080a154d 	.word	0x080a154d
 80a1bac:	080a1619 	.word	0x080a1619
